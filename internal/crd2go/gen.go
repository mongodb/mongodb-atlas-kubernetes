package crd2go

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

const (
	FirstVersion = ""

	CommentMaxWidth = 80
)

const (
	metav1Package = "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type GenerateConfig struct {
	Version        string
	Skips          []string
	PreloadedTypes []*GoType
}

// CodeWriterFunc is a function type that takes a CRD and returns a writer for the generated code
type CodeWriterFunc func(filename string, overwrite bool) (io.WriteCloser, error)

// CodeFileForCRDAtPath creates a file writer for the given CRD at the specified directory
func CodeFileForCRDAtPath(dir string) CodeWriterFunc {
	return func(filename string, overwrite bool) (io.WriteCloser, error) {
		srcFile := filepath.Join(dir, filename)
		flags := os.O_CREATE | os.O_EXCL | os.O_WRONLY
		if overwrite {
			flags = os.O_CREATE | os.O_TRUNC | os.O_RDWR
		}
		w, err := os.OpenFile(srcFile, flags, 0666)
		if err != nil {
			return nil, fmt.Errorf("failed to create file %s: %w", srcFile, err)
		}
		return w, nil
	}
}

// GenerateToDir generates Go code from a CRD YAML file into a directory
func GenerateToDir(outputDir, inputFile string, cfg *GenerateConfig) error {
	in, err := os.Open(inputFile)
	if err != nil {
		return fmt.Errorf("failed to open input file %s: %w", inputFile, err)
	}
	return Generate(CodeFileForCRDAtPath(outputDir), in, cfg)
}

// Generate will write files using the CodeWriterFunc
func Generate(cwFn CodeWriterFunc, r io.Reader, cfg *GenerateConfig) error {
	groupsVersions := map[string]struct{}{}
	group := ""
	version := ""
	generatedGVRs, err := GenerateStream(cwFn, r, cfg)
	if err != nil {
		return fmt.Errorf("failed to generate CRDs: %w", err)
	}
	for _, gvr := range generatedGVRs {
		parts := strings.Split(gvr, "/")
		if len(parts) > 2 {
			group = parts[0]
			version = parts[1]
			gv := fmt.Sprintf("%s/%s", group, version)
			groupsVersions[gv] = struct{}{}
		}
	}
	if len(groupsVersions) == 1 {
		if err := generateGroupVersionFiles(cwFn, group, version); err != nil {
			return fmt.Errorf("failed to generate files for group version '%s/%s': %w", group, version, err)
		}
	}
	return nil
}

func generateGroupVersionFiles(cwFn CodeWriterFunc, group, version string) error {
	if err := generateDocFile(cwFn, group, version); err != nil && !errors.Is(err, os.ErrExist) {
		return fmt.Errorf("failed to generate doc.go file: %w", err)
	}
	if err := generateSchemeFile(cwFn, group, version); err != nil && !errors.Is(err, os.ErrExist) {
		return fmt.Errorf("failed to generate schema.go file: %w", err)
	}
	return nil
}

func generateDocFile(cwFn CodeWriterFunc, group, version string) error {
	f := jen.NewFile(version)
	f.HeaderComment("Code generated by crd2go. DO NOT EDIT.")
	f.HeaderComment("+k8s:deepcopy-gen=package")
	f.HeaderComment(fmt.Sprintf("+groupName=%s", group))
	f.Add(jen.Commentf("controller-gen object paths=..."))
	overwrite := false
	wc, err := cwFn("doc.go", overwrite)
	if err != nil {
		return fmt.Errorf("failed to prepare doc.go for writting: %w", err)
	}
	if err := f.Render(wc); err != nil {
		return fmt.Errorf("failed to write Go code to doc.go: %w", err)
	}
	return nil
}

func generateSchemeFile(cwFn CodeWriterFunc, group, version string) error {
	f := jen.NewFile(version)
	f.HeaderComment("Code generated by crd2go. DO NOT EDIT.")
	f.Var().Defs(
		jen.Comment("GroupVersion is group version used to register these objects"),
		jen.Id("GroupVersion").Op("=").Qual("k8s.io/apimachinery/pkg/runtime/schema", "GroupVersion").Values(
			jen.Dict{
				jen.Id("Group"):   jen.Lit(group),
				jen.Id("Version"): jen.Lit(version),
			},
		),
		jen.Line(),
		jen.Comment("SchemeBuilder is used to add go types to the GroupVersionKind scheme"),
		jen.Id("SchemeBuilder").Op("=").Op("&").Qual("sigs.k8s.io/controller-runtime/pkg/scheme", "Builder").Values(
			jen.Dict{
				jen.Id("GroupVersion"): jen.Id("GroupVersion"),
			},
		),
		jen.Line(),
		jen.Comment("AddToScheme adds the types in this group-version to the given scheme"),
		jen.Id("AddToScheme").Op("=").Id("SchemeBuilder").Dot("AddToScheme"),
	)

	overwrite := true
	wc, err := cwFn("scheme.go", overwrite)
	if err != nil {
		return fmt.Errorf("failed to prepare scheme.go for writting: %w", err)
	}
	if err := f.Render(wc); err != nil {
		return fmt.Errorf("failed to write Go code to scheme.go: %w", err)
	}
	return nil
}

// GenerateStream generates Go code from a stream of CRDs within a YAML reader.
// It uses the provided CodeWriterFunc to write the generated code to the specified output.
// The version parameter specifies the version of the CRD to generate code for.
// The preloadedTypes parameter allows for preloading specific types to avoid name collisions.
func GenerateStream(cwFn CodeWriterFunc, r io.Reader, cfg *GenerateConfig) ([]string, error) {
	overwrite := true
	generatedGVRs := []string{}
	generated := false
	scanner := bufio.NewScanner(r)
	td := NewTypeDict(cfg.PreloadedTypes...)
	for {
		crd, err := ParseCRD(scanner)
		if errors.Is(err, io.EOF) {
			if generated {
				return generatedGVRs, nil
			}
			return nil, fmt.Errorf("failed to parse CRD: %w", err)
		}
		if err != nil {
			return nil, fmt.Errorf("failed to read input: %w", err)
		}
		if in(cfg.Skips, crd.Spec.Names.Kind) {
			continue
		}
		w, err := cwFn(crd2Filename(crd), overwrite)
		if err != nil {
			return nil, fmt.Errorf("failed to get writer for CRD %s: %w", crd.Name, err)
		}
		defer w.Close()
		crdVersion := selectVersion(&crd.Spec, cfg.Version)
		if crdVersion == nil {
			if cfg.Version == "" {
				return nil, fmt.Errorf("no versions to generate code from")
			}
			return nil, fmt.Errorf("no version %q to generate code from", cfg.Version)
		}
		stmt, err := generateCRD(td, crd, crdVersion)
		if err != nil {
			return nil, fmt.Errorf("failed to generate CRD code: %w", err)
		}
		if _, err := w.Write(([]byte)(stmt.GoString())); err != nil {
			return nil, fmt.Errorf("failed to write Go code: %w", err)
		}
		generated = true
		gvr := fmt.Sprintf("%s/%s/%s", crd.Spec.Group, crdVersion.Name, crd.Spec.Names.Plural)
		gvr = strings.TrimPrefix(gvr, "/")
		generatedGVRs = append(generatedGVRs, gvr)
	}
}

// generateCRD generates Go code for a CustomResourceDefinition (CRD) using the provided TypeDict and version
func generateCRD(td TypeDict, crd *apiextensions.CustomResourceDefinition, v *apiextensions.CustomResourceDefinitionVersion) (*jen.File, error) {
	f := jen.NewFile(v.Name)
	f.HeaderComment("Code generated by crd2go. DO NOT EDIT.")
	f.ImportAlias(metav1Package, "metav1")
	f.Func().Id("init").Params().Block(
		jen.Id("SchemeBuilder").Dot("Register").Params(
			jen.Op("&").Id(crd.Spec.Names.Kind).Values(),
		),
		jen.Id("SchemeBuilder").Dot("Register").Params(
			jen.Op("&").Id(crd.Spec.Names.Kind+"List").Values(),
		),
	)

	if err := generateCRDRootObject(f, td, crd, v); err != nil {
		return nil, fmt.Errorf("failed to generate root object: %w", err)
	}
	return f, nil
}

// generateCRDRootObject generates the root object for the CRD
func generateCRDRootObject(f *jen.File, td TypeDict, crd *apiextensions.CustomResourceDefinition, v *apiextensions.CustomResourceDefinitionVersion) error {
	f.Comment("+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object")
	f.Comment("+kubebuilder:object:root=true").Line()

	specType := fmt.Sprintf("%sSpec", crd.Spec.Names.Kind)
	statusType := fmt.Sprintf("%sStatus", crd.Spec.Names.Kind)

	code := f.Type().Id(crd.Spec.Names.Kind).Struct(
		jen.Qual(metav1Package, "TypeMeta").Tag(map[string]string{"json": ",inline"}),
		jen.Qual(metav1Package, "ObjectMeta").Tag(map[string]string{"json": "metadata,omitempty"}),
		jen.Line(),
		jen.Id("Spec").Id(specType).Tag(map[string]string{"json": "spec,omitempty"}),
		jen.Id("Status").Id(statusType).Tag(map[string]string{"json": "status,omitempty"}),
	)
	td.Add(NewStruct(crd.Spec.Names.Kind, nil)) // reserve the name of the root type not to be taken

	specSchema := v.Schema.OpenAPIV3Schema.Properties["spec"]
	spec, err := FromOpenAPIType(td, specType, []string{crd.Spec.Names.Kind}, &specSchema)
	if err != nil {
		return fmt.Errorf("failed to generate spec type: %w", err)
	}
	specCode, err := generateType(f, td, spec)
	if err != nil {
		return fmt.Errorf("failed to generate spec code: %w", err)
	}
	code.Add(specCode)

	statusSchema := v.Schema.OpenAPIV3Schema.Properties["status"]
	status, err := FromOpenAPIType(td, statusType, []string{crd.Spec.Names.Kind}, &statusSchema)
	if err != nil {
		return fmt.Errorf("failed to generate status code: %w", err)
	}
	statusCode, err := generateType(f, td, status)
	if err != nil {
		return fmt.Errorf("failed to generate status code: %w", err)
	}
	code.Add(statusCode)

	f.Comment("+kubebuilder:object:root=true")
	f.Type().Id(crd.Spec.Names.Kind+"List").Struct(
		jen.Qual(metav1Package, "TypeMeta").Tag(map[string]string{"json": ",inline"}),
		jen.Qual(metav1Package, "ListMeta").Tag(map[string]string{"json": "metadata,omitempty"}),
		jen.Id("Items").Index().Id(crd.Spec.Names.Kind).Tag(map[string]string{"json": "items"}),
	)

	return nil
}

// generateType generates Go code for a given type using the provided TypeDict
func generateType(f *jen.File, td TypeDict, t *GoType) (*jen.Statement, error) {
	if t.Import != nil { // do not generate code for known imported types
		return jen.Null(), nil
	}
	if t.Kind == StructKind {
		return generateStructType(f, td, t)
	}
	if t.Kind == ArrayKind {
		return generateArrayType(f, td, t)
	}
	if t.Kind == MapKind {
		return generateMapType(f, td, t)
	}
	return nil, fmt.Errorf("unsupported type %q", t.Kind)
}

// generateStructType generates Go code for a struct type
func generateStructType(f *jen.File, td TypeDict, t *GoType) (*jen.Statement, error) {
	fields := make([]jen.Code, 0, len(t.Fields))
	subtypes := make([]jen.Code, 0, len(t.Fields))
	for _, field := range t.Fields {
		fieldCode, err := generateField(f, field)
		if err != nil {
			return nil, fmt.Errorf("failed to generate field %s: %w", field.Name, err)
		}
		fields = append(fields, fieldCode)
		subtype, err := generateSubtype(f, td, field.GoType)
		if err != nil {
			return nil, fmt.Errorf("failed to generate field %s subtype: %w", field.Name, err)
		}
		subtypes = append(subtypes, subtype)
	}
	return jen.Line().Line().Type().Id(t.Name).Struct(fields...).Add(subtypes...), nil
}

// generateArrayType generates Go code for an array type
func generateArrayType(f *jen.File, td TypeDict, t *GoType) (*jen.Statement, error) {
	elementType, err := generateSubtype(f, td, t.Element)
	if err != nil {
		return nil, fmt.Errorf("failed to generate array subtype: %w", err)
	}
	return elementType, nil
}

// generateMapType generates Go code for an array type
func generateMapType(f *jen.File, td TypeDict, t *GoType) (*jen.Statement, error) {
	elementType, err := generateSubtype(f, td, t.Element)
	if err != nil {
		return nil, fmt.Errorf("failed to generate map subtype: %w", err)
	}
	return elementType, nil
}

// generateSubtype generates Go code for a subtype of a given type
func generateSubtype(f *jen.File, td TypeDict, t *GoType) (*jen.Statement, error) {
	baseType := t.baseType()
	if !baseType.isPrimitive() && !td.WasGenerated(baseType) {
		subtypeCode, err := generateType(f, td, baseType)
		if err != nil {
			return nil, fmt.Errorf("failed to generate subtype %s: %w", t.Name, err)
		}
		td.MarkGenerated(baseType)
		return subtypeCode, nil
	}
	return jen.Null(), nil
}

// generateField generates Go code for a field in a struct
func generateField(f *jen.File, field *GoField) (jen.Code, error) {
	if field.GoType == nil {
		return nil, fmt.Errorf("field %q has no Go type", field.Name)
	}
	typeRefCode, err := qualifyRequired(generateTypeRef(f, field.GoType), field.Required)
	if err != nil {
		return nil, fmt.Errorf("failed to generate field type: %w", err)
	}
	fieldCode := jen.Null()
	if field.Comment != "" {
		fieldCode = generateFieldComment(fieldCode, field.Name, field.Comment)
	}
	return fieldCode.Id(field.Name).Add(typeRefCode).Add(generateJSONTag(field)).Line(), nil
}

// generateFieldComment generates a comment for a field in a struct
func generateFieldComment(code *jen.Statement, name, comment string) *jen.Statement {
	goComment := fmt.Sprintf("%s %s", name, comment)
	lines := formatComment(goComment, CommentMaxWidth)
	for _, line := range lines {
		code.Add(jen.Comment(line).Line())
	}
	return code
}

// qualifyRequired qualifies the type reference based on whether the field is required
func qualifyRequired(typeRef *jen.Statement, required bool) (*jen.Statement, error) {
	if required {
		return typeRef, nil
	}
	return jen.Op("*").Add(typeRef), nil
}

// generateTypeRef generates a type reference for a given GoType
func generateTypeRef(f *jen.File, t *GoType) *jen.Statement {
	switch t.Kind {
	case StringKind:
		return jen.String()
	case IntKind:
		return jen.Int()
	case FloatKind:
		return jen.Float64()
	case BoolKind:
		return jen.Bool()
	case ArrayKind:
		return jen.Index().Add(generateTypeRef(f, t.Element))
	case MapKind:
		return jen.Map(jen.String()).Add(generateTypeRef(f, t.Element))
	default:
		if t.Import != nil {
			if t.Import.Alias != "" {
				f.ImportAlias(t.Import.Path, t.Import.Alias)
			}
			return jen.Qual(t.Import.Path, title(t.Name))
		}
		return jen.Id(title(t.Name))
	}
}

// generateJSONTag generates a JSON tag for a field in a struct
func generateJSONTag(f *GoField) *jen.Statement {
	jsTag := fmt.Sprintf("%s,omitempty", f.Key)
	if f.Required {
		jsTag = fmt.Sprintf("%s", f.Key)
	}
	return jen.Tag(map[string]string{"json": jsTag})
}

// selectVersion returns the version from the CRD spec that matches the given version string
func selectVersion(spec *apiextensions.CustomResourceDefinitionSpec, version string) *apiextensions.CustomResourceDefinitionVersion {
	if len(spec.Versions) == 0 {
		return nil
	}
	if version == "" {
		return &spec.Versions[0]
	}
	for _, v := range spec.Versions {
		if v.Name == version {
			return &v
		}
	}
	return nil
}

// title capitalizes the first letter of a string and returns it using Go cases library
func title(s string) string {
	if s == "" {
		return ""
	}
	s = strings.TrimLeft(s, "_") // remove leading underscores
	return cases.Upper(language.English).String(s[0:1]) + s[1:]
}

// untitle de-capitalizes the first letter of a string and returns it using Go cases library
func untitle(s string) string {
	if s == "" {
		return ""
	}
	return cases.Lower(language.English).String(s[0:1]) + s[1:]
}

// formatComment formats a comment string to fit within a specified width,
// without splitting words.
func formatComment(comment string, maxWidth int) []string {
	if strings.Contains(comment, "\n") {
		return []string{comment}
	}

	words := strings.Fields(comment)
	var lines []string
	var currentLine string

	for _, word := range words {
		if len(currentLine)+len(word)+1 > maxWidth {
			lines = append(lines, currentLine)
			currentLine = word
		} else {
			if currentLine != "" {
				currentLine += " "
			}
			currentLine += word
		}
	}
	if currentLine != "" {
		lines = append(lines, currentLine)
	}
	return lines
}

func in[T comparable](list []T, target T) bool {
	for _, item := range list {
		if item == target {
			return true
		}
	}
	return false
}

func crd2Filename(crd *apiextensions.CustomResourceDefinition) string {
	return fmt.Sprintf("%s.go", strings.ToLower(crd.Spec.Names.Kind))
}
