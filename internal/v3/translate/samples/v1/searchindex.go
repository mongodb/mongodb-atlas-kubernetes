// Code generated by crd2go. DO NOT EDIT.

package v1

import (
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/k8s"
)

func init() {
	SchemeBuilder.Register(&SearchIndex{})
	SchemeBuilder.Register(&SearchIndexList{})
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

type SearchIndex struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   SearchIndexSpec   `json:"spec,omitempty"`
	Status SearchIndexStatus `json:"status,omitempty"`
}

type SearchIndexSpec struct {
	// V20250312 The spec of the searchindex resource for version v20250312.
	V20250312 *SearchIndexSpecV20250312 `json:"v20250312,omitempty"`
}

type SearchIndexSpecV20250312 struct {
	// ClusterName Name of the cluster that contains the collection on which to create
	// an Atlas Search index.
	ClusterName string `json:"clusterName"`

	// Entry The entry fields of the searchindex resource spec. These fields can be set
	// for creating and updating searchindexes.
	Entry *SearchIndexSpecV20250312Entry `json:"entry,omitempty"`

	/*
	   GroupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

	   **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	*/
	GroupId *string `json:"groupId,omitempty"`

	/*
	   GroupRef A reference to a "Group" resource.
	   The value of "$.status.v20250312.id" will be used to set "groupId".
	   Mutually exclusive with the "groupId" property.
	*/
	GroupRef *k8s.LocalReference `json:"groupRef,omitempty"`
}

type SearchIndexSpecV20250312Entry struct {
	// CollectionName Label that identifies the collection to create an Atlas Search
	// index in.
	CollectionName string `json:"collectionName"`

	// Database Label that identifies the database that contains the collection to
	// create an Atlas Search index in.
	Database string `json:"database"`

	Definition *Definition `json:"definition,omitempty"`

	// Name Label that identifies this index. Within each namespace, names of all
	// indexes in the namespace must be unique.
	Name string `json:"name"`

	// Type Type of the index. The default type is search.
	Type *string `json:"type,omitempty"`
}

type Definition struct {
	/*
	   Analyzer Specific pre-defined method chosen to convert database field text into searchable words. This conversion reduces the text of fields into the smallest units of text. These units are called a **term** or **token**. This process, known as tokenization, involves making the following changes to the text in fields:

	   - extracting words
	   - removing punctuation
	   - removing accents
	   - changing to lowercase
	   - removing common words
	   - reducing words to their root form (stemming)
	   - changing words to their base form (lemmatization)
	    MongoDB Cloud uses the process you select to build the Atlas Search index.
	*/
	Analyzer *string `json:"analyzer,omitempty"`

	// Analyzers List of user-defined methods to convert database field text into
	// searchable words.
	Analyzers *[]Analyzers `json:"analyzers,omitempty"`

	// Fields Settings that configure the fields, one per object, to index. You must
	// define at least one "vector" type field. You can optionally define "filter" type
	// fields also.
	Fields *[]apiextensionsv1.JSON `json:"fields,omitempty"`

	// Mappings Index specifications for the collection's fields.
	Mappings *Mappings `json:"mappings,omitempty"`

	// NumPartitions Number of index partitions. Allowed values are [1, 2, 4].
	NumPartitions *int `json:"numPartitions,omitempty"`

	// SearchAnalyzer Method applied to identify words when searching this index.
	SearchAnalyzer *string `json:"searchAnalyzer,omitempty"`

	// StoredSource Flag that indicates whether to store all fields (true) on Atlas
	// Search. By default, Atlas doesn't store (false) the fields on Atlas Search.
	// Alternatively, you can specify an object that only contains the list of fields
	// to store (include) or not store (exclude) on Atlas Search. To learn more, see
	// Stored Source Fields.
	StoredSource *apiextensionsv1.JSON `json:"storedSource,omitempty"`

	// Synonyms Rule sets that map words to their synonyms in this index.
	Synonyms *[]Synonyms `json:"synonyms,omitempty"`
}

type Analyzers struct {
	// CharFilters Filters that examine text one character at a time and perform
	// filtering operations.
	CharFilters *[]apiextensionsv1.JSON `json:"charFilters,omitempty"`

	/*
	   Name Name that identifies the custom analyzer. Names must be unique within an index, and must not start with any of the following strings:
	   - `lucene.`
	   - `builtin.`
	   - `mongodb.`
	*/
	Name string `json:"name"`

	/*
	   TokenFilters Filter that performs operations such as:

	   - Stemming, which reduces related words, such as "talking", "talked", and "talks" to their root word "talk".

	   - Redaction, which is the removal of sensitive information from public documents.
	*/
	TokenFilters *[]apiextensionsv1.JSON `json:"tokenFilters,omitempty"`

	// Tokenizer Tokenizer that you want to use to create tokens. Tokens determine how
	// Atlas Search splits up text into discrete chunks for indexing.
	Tokenizer apiextensionsv1.JSON `json:"tokenizer"`
}

type Mappings struct {
	// Dynamic Flag that indicates whether the index uses dynamic or static mappings.
	// Required if **mappings.fields** is omitted.
	Dynamic *bool `json:"dynamic,omitempty"`

	// Fields One or more field specifications for the Atlas Search index. Required if
	// **mappings.dynamic** is omitted or set to **false**.
	Fields *map[string]apiextensionsv1.JSON `json:"fields,omitempty"`
}

type Synonyms struct {
	// Analyzer Specific pre-defined method chosen to apply to the synonyms to be
	// searched.
	Analyzer string `json:"analyzer"`

	// Name Label that identifies the synonym definition. Each **synonym.name** must be
	// unique within the same index definition.
	Name string `json:"name"`

	// Source Data set that stores words and their applicable synonyms.
	Source Source `json:"source"`
}

type Source struct {
	// Collection Label that identifies the MongoDB collection that stores words and
	// their applicable synonyms.
	Collection string `json:"collection"`
}

type SearchIndexStatus struct {
	// Conditions Represents the latest available observations of a resource's current
	// state.
	Conditions *[]metav1.Condition `json:"conditions,omitempty"`

	// V20250312 The last observed Atlas state of the searchindex resource for version
	// v20250312.
	V20250312 *SearchIndexStatusV20250312 `json:"v20250312,omitempty"`
}

type SearchIndexStatusV20250312 struct {
	// CollectionName Label that identifies the collection that contains one or more
	// Atlas Search indexes.
	CollectionName *string `json:"collectionName,omitempty"`

	// Database Label that identifies the database that contains the collection with
	// one or more Atlas Search indexes.
	Database *string `json:"database,omitempty"`

	// IndexID Unique 24-hexadecimal digit string that identifies this Atlas Search
	// index.
	IndexID *string `json:"indexID,omitempty"`

	// LatestDefinitionVersion Object which includes the version number of the index
	// definition and the time that the index definition was created.
	LatestDefinitionVersion *LatestDefinitionVersion `json:"latestDefinitionVersion,omitempty"`

	// Name Label that identifies this index. Within each namespace, the names of all
	// indexes must be unique.
	Name *string `json:"name,omitempty"`

	// Queryable Flag that indicates whether the index is queryable on all hosts.
	Queryable *bool `json:"queryable,omitempty"`

	/*
	   Status Condition of the search index when you made this request.

	   - `DELETING`: The index is being deleted.
	   - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
	   - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
	   - `PENDING`: Atlas has not yet started building the index.
	   - `BUILDING`: Atlas is building or re-building the index after an edit.
	   - `READY`: The index is ready and can support queries.
	*/
	Status *string `json:"status,omitempty"`

	// StatusDetail List of documents detailing index status on each host.
	StatusDetail *[]StatusDetail `json:"statusDetail,omitempty"`

	// SynonymMappingStatus Status that describes this index's synonym mappings. This
	// status appears only if the index has synonyms defined.
	SynonymMappingStatus *string `json:"synonymMappingStatus,omitempty"`

	// SynonymMappingStatusDetail A list of documents describing the status of the
	// index's synonym mappings on each search host. Only appears if the index has
	// synonyms defined.
	SynonymMappingStatusDetail *[]map[string]SynonymMappingStatusDetail `json:"synonymMappingStatusDetail,omitempty"`

	// Type Type of the index. The default type is search.
	Type *string `json:"type,omitempty"`
}

type LatestDefinitionVersion struct {
	// CreatedAt The time at which this index definition was created. This parameter
	// expresses its value in the ISO 8601 timestamp format in UTC.
	CreatedAt *string `json:"createdAt,omitempty"`

	// Version The version number associated with this index definition when it was
	// created.
	Version *int `json:"version,omitempty"`
}

type StatusDetail struct {
	// Hostname Hostname that corresponds to the status detail.
	Hostname *string `json:"hostname,omitempty"`

	// MainIndex Contains status information about a vector search index.
	MainIndex *MainIndex `json:"mainIndex,omitempty"`

	// Queryable Flag that indicates whether the index is queryable on the host.
	Queryable *bool `json:"queryable,omitempty"`

	// StagedIndex Contains status information about a vector search index.
	StagedIndex *MainIndex `json:"stagedIndex,omitempty"`

	/*
	   Status Condition of the search index when you made this request.

	   - `DELETING`: The index is being deleted.
	   - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
	   - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
	   - `PENDING`: Atlas has not yet started building the index.
	   - `BUILDING`: Atlas is building or re-building the index after an edit.
	   - `READY`: The index is ready and can support queries.
	*/
	Status *string `json:"status,omitempty"`
}

type MainIndex struct {
	// Definition The vector search index definition set by the user.
	Definition *MainIndexDefinition `json:"definition,omitempty"`

	// DefinitionVersion Object which includes the version number of the index
	// definition and the time that the index definition was created.
	DefinitionVersion *LatestDefinitionVersion `json:"definitionVersion,omitempty"`

	// Message Optional message describing an error.
	Message *string `json:"message,omitempty"`

	// Queryable Flag that indicates whether the index generation is queryable on the
	// host.
	Queryable *bool `json:"queryable,omitempty"`

	/*
	   Status Condition of the search index when you made this request.

	   - `DELETING`: The index is being deleted.
	   - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
	   - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
	   - `PENDING`: Atlas has not yet started building the index.
	   - `BUILDING`: Atlas is building or re-building the index after an edit.
	   - `READY`: The index is ready and can support queries.
	*/
	Status *string `json:"status,omitempty"`
}

type MainIndexDefinition struct {
	// Fields Settings that configure the fields, one per object, to index. You must
	// define at least one "vector" type field. You can optionally define "filter" type
	// fields also.
	Fields *[]apiextensionsv1.JSON `json:"fields,omitempty"`

	// NumPartitions Number of index partitions. Allowed values are [1, 2, 4].
	NumPartitions *int `json:"numPartitions,omitempty"`
}

type SynonymMappingStatusDetail struct {
	// Message Optional message describing an error.
	Message *string `json:"message,omitempty"`

	// Queryable Flag that indicates whether the synonym mapping is queryable on a
	// host.
	Queryable *bool `json:"queryable,omitempty"`

	// Status Status that describes this index's synonym mappings. This status appears
	// only if the index has synonyms defined.
	Status *string `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
type SearchIndexList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SearchIndex `json:"items"`
}
