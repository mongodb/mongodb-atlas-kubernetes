// Code generated by crd2go. DO NOT EDIT.

package v1

import (
	k8s "github.com/josvazg/crd2go/k8s"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func init() {
	SchemeBuilder.Register(&DataFederation{})
	SchemeBuilder.Register(&DataFederationList{})
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

type DataFederation struct {
	metav1.TypeMeta `json:",inline"`

	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec DataFederationSpec `json:"spec,omitempty"`

	Status DataFederationStatus `json:"status,omitempty"`
}

type DataFederationSpec struct {
	// V20250312 The spec of the datafederation resource for version v20250312.
	V20250312 *DataFederationSpecV20250312 `json:"v20250312,omitempty"`
}

type DataFederationSpecV20250312 struct {
	// Entry The entry fields of the datafederation resource spec. These fields can be
	// set for creating and updating datafederations.
	Entry *DataFederationSpecV20250312Entry `json:"entry,omitempty"`

	/*
	   GroupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

	   **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	*/
	GroupId *string `json:"groupId,omitempty"`

	/*
	   GroupRef A reference to a "Group" resource.
	   The value of "$.status.v20250312.id" will be used to set "groupId".
	   Mutually exclusive with the "groupId" property.
	*/
	GroupRef *k8s.LocalReference `json:"groupRef,omitempty"`

	// SkipRoleValidation Flag that indicates whether this request should check if the
	// requesting IAM role can read from the S3 bucket. AWS checks if the role can list
	// the objects in the bucket before writing to it. Some IAM roles only need write
	// permissions. This flag allows you to skip that check.
	SkipRoleValidation bool `json:"skipRoleValidation"`
}

type DataFederationSpecV20250312Entry struct {
	// CloudProviderConfig Cloud provider where this Federated Database Instance is
	// hosted.
	CloudProviderConfig *CloudProviderConfig `json:"cloudProviderConfig,omitempty"`

	// DataProcessRegion Information about the cloud provider region to which the
	// Federated Database Instance routes client connections.
	DataProcessRegion *DataProcessRegion `json:"dataProcessRegion,omitempty"`

	// Name Human-readable label that identifies the Federated Database Instance.
	Name *string `json:"name,omitempty"`

	// Storage Configuration information for each data store and its mapping to MongoDB
	// Cloud databases.
	Storage *Storage `json:"storage,omitempty"`
}

type CloudProviderConfig struct {
	// Aws Configuration for running Data Federation in AWS.
	Aws *Aws `json:"aws,omitempty"`

	// Azure Configuration for running Data Federation in Azure.
	Azure *Azure `json:"azure,omitempty"`

	// Gcp Configuration for running Data Federation in GCP.
	Gcp *Azure `json:"gcp,omitempty"`
}

type Aws struct {
	// RoleId Unique identifier of the role that the data lake can use to access the
	// data stores.Required if specifying cloudProviderConfig.
	RoleId string `json:"roleId"`

	// TestS3Bucket Name of the S3 data bucket that the provided role ID is authorized
	// to access.Required if specifying cloudProviderConfig.
	TestS3Bucket string `json:"testS3Bucket"`
}

type Azure struct {
	// RoleId Unique identifier of the role that Data Federation can use to access the
	// data stores. Required if specifying cloudProviderConfig.
	RoleId string `json:"roleId"`
}

type DataProcessRegion struct {
	// CloudProvider Name of the cloud service that hosts the Federated Database
	// Instance's infrastructure.
	CloudProvider string `json:"cloudProvider"`

	// Region Name of the region to which the data lake routes client connections.
	Region string `json:"region"`
}

type Storage struct {
	// Databases Array that contains the queryable databases and collections for this
	// data lake.
	Databases *[]Databases `json:"databases,omitempty"`

	// Stores Array that contains the data stores for the data lake.
	Stores *[]Stores `json:"stores,omitempty"`
}

type Databases struct {
	// Collections Array of collections and data sources that map to a ``stores`` data
	// store.
	Collections *[]Collections `json:"collections,omitempty"`

	// MaxWildcardCollections Maximum number of wildcard collections in the database.
	// This only applies to S3 data sources.
	MaxWildcardCollections *int `json:"maxWildcardCollections,omitempty"`

	// Name Human-readable label that identifies the database to which the data lake
	// maps data.
	Name *string `json:"name,omitempty"`

	// Views Array of aggregation pipelines that apply to the collection. This only
	// applies to S3 data sources.
	Views *[]Views `json:"views,omitempty"`
}

type Collections struct {
	// DataSources Array that contains the data stores that map to a collection for
	// this data lake.
	DataSources *[]DataSources `json:"dataSources,omitempty"`

	// Name Human-readable label that identifies the collection to which MongoDB Cloud
	// maps the data in the data stores.
	Name *string `json:"name,omitempty"`
}

type DataSources struct {
	// AllowInsecure Flag that validates the scheme in the specified URLs. If `true`,
	// allows insecure `HTTP` scheme, doesn't verify the server's certificate chain and
	// hostname, and accepts any certificate with any hostname presented by the server.
	// If `false`, allows secure `HTTPS` scheme only.
	AllowInsecure *bool `json:"allowInsecure,omitempty"`

	// Collection Human-readable label that identifies the collection in the database.
	// For creating a wildcard (`*`) collection, you must omit this parameter.
	Collection *string `json:"collection,omitempty"`

	// CollectionRegex Regex pattern to use for creating the wildcard (*) collection.
	// To learn more about the regex syntax, see [Go programming
	// language](https://pkg.go.dev/regexp).
	CollectionRegex *string `json:"collectionRegex,omitempty"`

	// Database Human-readable label that identifies the database, which contains the
	// collection in the cluster. You must omit this parameter to generate wildcard
	// (`*`) collections for dynamically generated databases.
	Database *string `json:"database,omitempty"`

	// DatabaseRegex Regex pattern to use for creating the wildcard (*) database. To
	// learn more about the regex syntax, see [Go programming
	// language](https://pkg.go.dev/regexp).
	DatabaseRegex *string `json:"databaseRegex,omitempty"`

	// DatasetName Human-readable label that identifies the dataset that Atlas
	// generates for an ingestion pipeline run or Online Archive.
	DatasetName *string `json:"datasetName,omitempty"`

	// DatasetPrefix Human-readable label that matches against the dataset names for
	// ingestion pipeline runs or Online Archives.
	DatasetPrefix *string `json:"datasetPrefix,omitempty"`

	// DefaultFormat File format that MongoDB Cloud uses if it encounters a file
	// without a file extension while searching **storeName**.
	DefaultFormat *string `json:"defaultFormat,omitempty"`

	// Path File path that controls how MongoDB Cloud searches for and parses files in
	// the **storeName** before mapping them to a collection.Specify ``/`` to capture
	// all files and folders from the ``prefix`` path.
	Path *string `json:"path,omitempty"`

	// ProvenanceFieldName Name for the field that includes the provenance of the
	// documents in the results. MongoDB Cloud returns different fields in the results
	// for each supported provider.
	ProvenanceFieldName *string `json:"provenanceFieldName,omitempty"`

	// StoreName Human-readable label that identifies the data store that MongoDB Cloud
	// maps to the collection.
	StoreName *string `json:"storeName,omitempty"`

	// TrimLevel Unsigned integer that specifies how many fields of the dataset name to
	// trim from the left of the dataset name before mapping the remaining fields to a
	// wildcard collection name.
	TrimLevel *int `json:"trimLevel,omitempty"`

	// Urls URLs of the publicly accessible data files. You can't specify URLs that
	// require authentication. Atlas Data Lake creates a partition for each URL. If
	// empty or omitted, Data Lake uses the URLs from the store specified in the
	// **dataSources.storeName** parameter.
	Urls *[]string `json:"urls,omitempty"`
}

type Views struct {
	// Name Human-readable label that identifies the view, which corresponds to an
	// aggregation pipeline on a collection.
	Name *string `json:"name,omitempty"`

	// Pipeline Aggregation pipeline stages to apply to the source collection.
	Pipeline *string `json:"pipeline,omitempty"`

	// Source Human-readable label that identifies the source collection for the view.
	Source *string `json:"source,omitempty"`
}

type Stores struct {
	// AdditionalStorageClasses Collection of AWS S3 [storage
	// classes](https://aws.amazon.com/s3/storage-classes/). Atlas Data Lake includes
	// the files in these storage classes in the query results.
	AdditionalStorageClasses *[]string `json:"additionalStorageClasses,omitempty"`

	// AllowInsecure Flag that validates the scheme in the specified URLs. If `true`,
	// allows insecure `HTTP` scheme, doesn't verify the server's certificate chain and
	// hostname, and accepts any certificate with any hostname presented by the server.
	// If `false`, allows secure `HTTPS` scheme only.
	AllowInsecure *bool `json:"allowInsecure,omitempty"`

	// Bucket Human-readable label that identifies the Google Cloud Storage bucket.
	Bucket *string `json:"bucket,omitempty"`

	// ClusterName Human-readable label of the MongoDB Cloud cluster on which the store
	// is based.
	ClusterName *string `json:"clusterName,omitempty"`

	// ContainerName Human-readable label that identifies the name of the container.
	ContainerName *string `json:"containerName,omitempty"`

	// DefaultFormat Default format that Data Lake assumes if it encounters a file
	// without an extension while searching the `storeName`. If omitted, Data Lake
	// attempts to detect the file type by processing a few bytes of the file. The
	// specified format only applies to the URLs specified in the
	// **databases.[n].collections.[n].dataSources** object.
	DefaultFormat *string `json:"defaultFormat,omitempty"`

	// Delimiter Delimiter.
	Delimiter *string `json:"delimiter,omitempty"`

	// IncludeTags Flag that indicates whether to use S3 tags on the files in the given
	// path as additional partition attributes. If set to `true`, data lake adds the S3
	// tags as additional partition attributes and adds new top-level BSON elements
	// associating each tag to each document.
	IncludeTags *bool `json:"includeTags,omitempty"`

	// Name Human-readable label that identifies the data store. The
	// **databases.[n].collections.[n].dataSources.[n].storeName** field references
	// this values as part of the mapping configuration. To use MongoDB Cloud as a data
	// store, the data lake requires a serverless instance or an `M10` or higher
	// cluster.
	Name *string `json:"name,omitempty"`

	// Prefix Prefix.
	Prefix *string `json:"prefix,omitempty"`

	Provider string `json:"provider"`

	// Public Flag that indicates whether the bucket is public. If set to `true`,
	// MongoDB Cloud doesn't use the configured GCP service account to access the
	// bucket. If set to `false`, the configured GCP service acccount must include
	// permissions to access the bucket.
	Public *bool `json:"public,omitempty"`

	// ReadConcern MongoDB Cloud cluster read concern, which determines the consistency
	// and isolation properties of the data read from an Atlas cluster.
	ReadConcern *ReadConcern `json:"readConcern,omitempty"`

	// ReadPreference MongoDB Cloud cluster read preference, which describes how to
	// route read requests to the cluster.
	ReadPreference *ReadPreference `json:"readPreference,omitempty"`

	// Region Google Cloud Platform Regions.
	Region *string `json:"region,omitempty"`

	// ReplacementDelimiter Replacement Delimiter.
	ReplacementDelimiter *string `json:"replacementDelimiter,omitempty"`

	// ServiceURL Service URL.
	ServiceURL *string `json:"serviceURL,omitempty"`

	// Urls Comma-separated list of publicly accessible HTTP URLs where data is stored.
	// You can't specify URLs that require authentication.
	Urls *[]string `json:"urls,omitempty"`
}

type ReadConcern struct {
	// Level Read Concern level that specifies the consistency and availability of the
	// data read.
	Level *string `json:"level,omitempty"`
}

type ReadPreference struct {
	// MaxStalenessSeconds Maximum replication lag, or **staleness**, for reads from
	// secondaries.
	MaxStalenessSeconds *int `json:"maxStalenessSeconds,omitempty"`

	// Mode Read preference mode that specifies to which replica set member to route
	// the read requests.
	Mode *string `json:"mode,omitempty"`

	// TagSets List that contains tag sets or tag specification documents. If
	// specified, Atlas Data Lake routes read requests to replica set member or members
	// that are associated with the specified tags.
	TagSets *[][]TagSets `json:"tagSets,omitempty"`
}

type TagSets struct {
	// Name Human-readable label of the tag.
	Name *string `json:"name,omitempty"`

	// Value Value of the tag.
	Value *string `json:"value,omitempty"`
}

type DataFederationStatus struct {
	// Conditions Represents the latest available observations of a resource's current
	// state.
	Conditions *[]metav1.Condition `json:"conditions,omitempty"`

	// V20250312 The last observed Atlas state of the datafederation resource for
	// version v20250312.
	V20250312 *DataFederationStatusV20250312 `json:"v20250312,omitempty"`
}

type DataFederationStatusV20250312 struct {
	// GroupId Unique 24-hexadecimal character string that identifies the project.
	GroupId *string `json:"groupId,omitempty"`

	// Hostnames List that contains the hostnames assigned to the Federated Database
	// Instance.
	Hostnames *[]string `json:"hostnames,omitempty"`

	// PrivateEndpointHostnames List that contains the sets of private endpoints and
	// hostnames.
	PrivateEndpointHostnames *[]PrivateEndpointHostnames `json:"privateEndpointHostnames,omitempty"`

	// State Label that indicates the status of the Federated Database Instance.
	State *string `json:"state,omitempty"`
}

type PrivateEndpointHostnames struct {
	// Hostname Human-readable label that identifies the hostname.
	Hostname *string `json:"hostname,omitempty"`

	// PrivateEndpoint Human-readable label that identifies private endpoint.
	PrivateEndpoint *string `json:"privateEndpoint,omitempty"`
}

// +kubebuilder:object:root=true
type DataFederationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DataFederation `json:"items"`
}
