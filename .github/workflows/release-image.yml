name: Release Image

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Release version (without v prefix)"
        required: true
        type: string
      authors:
        description: "Comma-separated list of author emails"
        required: true
        type: string
      image_sha:
        description: "7-digit commit SHA used for the promoted image (e.g. 3e79a3f or 'latest')"
        required: false
        default: "latest"
        type: string
      release_type:
        description: "Official releases post to official registries, otherwise post to pre-release registries"
        type: choice
        default: pre-release
        options:
        - pre-release
        - official-release

permissions:
  contents: write
  pull-requests: write

jobs:
  # Image2commit: Creates a mapping between the image_sha given as input and the actual git commit
  # This is necessary for the release-image step that requires checking out that exact git commit
  image2commit:
    name: Resolve Commit SHA from Image
    runs-on: ubuntu-latest
    environment: release
    outputs:
      commit_sha: ${{ steps.resolve.outputs.commit_sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Log in to Docker registry
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Run image2commit
        id: resolve
        uses: ./.github/actions/image2commit
        with:
          registry: docker.io
          repo: mongodb/mongodb-atlas-kubernetes-operator-prerelease
          image_sha: ${{ github.event.inputs.image_sha }}

  # Check-commit: Outputs the commit used when someone wants to use latest image_sha
  # and does not know what version of operator will end up using
  check-commit:
    name: Check resolved commit
    runs-on: ubuntu-latest
    needs: image2commit
    steps:
      - name: Echo resolved commit
        run: |
          echo "Resolved commit: ${{ needs.image2commit.outputs.commit_sha }}"
        
  # Computes the release repo depending on release_type
  # official-release is mongodb/mongodb-atlas-kubernetes-operator
  # pre-release is mongodb/mongodb-atlas-kubernetes-operator-prerelease
  compute-repo:
    name: Compute target repos
    runs-on: ubuntu-latest
    needs: image2commit
    env:
      RELEASE_TYPE: ${{ github.event.inputs.release_type }}
    outputs:
      repo: ${{ steps.compute.outputs.repo }}
      version: ${{ steps.read_version.outputs.version }}
      image_version: ${{ steps.read_version.outputs.image_version }}
    steps:
    - name: Compute
      id: compute
      run: |
        if [ "${RELEASE_TYPE}" == "official-release" ]; then
          echo "Setting official release repo mongodb/mongodb-atlas-kubernetes-operator"
          echo "repo=mongodb/mongodb-atlas-kubernetes-operator" | tee -a $GITHUB_OUTPUT
        else
          echo "Setting pre-release repo mongodb/mongodb-atlas-kubernetes-operator-prerelease"
          echo "repo=mongodb/mongodb-atlas-kubernetes-operator-prerelease" | tee -a $GITHUB_OUTPUT
        fi
    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
        ref: ${{ needs.image2commit.outputs.commit_sha }}
    - name: Read the next release version
      id: read_version
      env:
        INPUT_VERSION: ${{ github.event.inputs.version }}
        RELEASE_TYPE: ${{ env.RELEASE_TYPE }}
      run: |
        VERSION=$(jq -r '.next' version.json)
        if [[ "$INPUT_VERSION" != "$VERSION" ]]; then
          echo "::error::Input version '$INPUT_VERSION' does not match the expected 'next' version '$VERSION' from version.json."
          exit 1
        fi
        # Compute image version based on release type
        if [ "${RELEASE_TYPE}" == "pre-release" ]; then
          IMAGE_VERSION="${VERSION}-pre-release"
        else
          IMAGE_VERSION="${VERSION}"
        fi
        echo "version=${VERSION}" >> "${GITHUB_OUTPUT}"
        echo "image_version=${IMAGE_VERSION}" >> "${GITHUB_OUTPUT}"

  # Release-image: Created and uploads a release for the specified operator version given in the image_sha
  # Note, with new releases, all the release artifacts will be stored within docs/releases/{version}
  release-image:
    name: Release images
    runs-on: ubuntu-latest
    environment: release
    needs:
    - image2commit
    - compute-repo
    env:
      VERSION: ${{ needs.compute-repo.outputs.version }}
      RELEASE_TAG: v${{ needs.compute-repo.outputs.image_version }}
      AUTHORS: ${{ github.event.inputs.authors }}
      IMAGE_SHA: ${{ github.event.inputs.image_sha }}
      DOCKER_SIGNATURE_REPO: docker.io/mongodb/signatures
      DOCKER_RELEASE_REPO: ${{ needs.compute-repo.outputs.repo }}
      DOCKER_PRERELEASE_REPO: docker.io/mongodb/mongodb-atlas-kubernetes-operator-prerelease
      QUAY_RELEASE_REPO: quay.io/${{ needs.compute-repo.outputs.repo }}
      QUAY_PRERELEASE_REPO: quay.io/mongodb/mongodb-atlas-kubernetes-operator-prerelease
      PROMOTED_TAG: promoted-${{ github.event.inputs.image_sha }}
      CERTIFIED_TAG: ${{ needs.compute-repo.outputs.image_version }}-certified
      DEST_PRERELEASE_REPO: docker.io/mongodb/mongodb-atlas-kubernetes-operator-prerelease
      DOCKER_IMAGE_URL: ${{ needs.compute-repo.outputs.repo }}:${{ needs.compute-repo.outputs.image_version }}
      QUAY_IMAGE_URL: quay.io/${{ needs.compute-repo.outputs.repo }}:${{ needs.compute-repo.outputs.image_version }}
      QUAY_CERTIFIED_IMAGE_URL: quay.io/${{ needs.compute-repo.outputs.repo }}:${{ needs.compute-repo.outputs.image_version }}-certified
    steps:
      - name: Checkout CI branch (workflow branch)
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Checkout released commit to released-branch/
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ needs.image2commit.outputs.commit_sha }}
          path: released-branch

      - name: Replace Makefile and scripts with CI branch versions
        run: |
          # Backup released-branch's Makefile and scripts if they exist
          [ -f released-branch/Makefile ] && mv released-branch/Makefile released-branch/Makefile.bak || true
          [ -d released-branch/scripts ] && mv released-branch/scripts released-branch/scripts.bak || true
          # Copy CI branch's Makefile and scripts to a stable location
          mkdir -p .ci-tooling
          cp Makefile .ci-tooling/
          cp -r scripts .ci-tooling/
          # Replace with symlinks to CI branch versions (use absolute path via .ci-tooling)
          ln -s "$(pwd)/.ci-tooling/Makefile" released-branch/Makefile
          ln -s "$(pwd)/.ci-tooling/scripts" released-branch/scripts
          # Copy devbox.json and devbox.lock to released-branch so devbox can set up the environment correctly
          cp devbox.json released-branch/
          cp devbox.lock released-branch/

      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.AKO_RELEASER_APP_ID }}
          private-key: ${{ secrets.AKO_RELEASER_RSA_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: |
            mongodb-atlas-kubernetes

      # Login in into all registries
      - name: Log in to Docker registry
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Log in to Quay registry
        uses: docker/login-action@v3
        with:
          registry: quay.io
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_PASSWORD }}

      - name: Log in to Artifactory
        uses: docker/login-action@v3
        with:
          registry: artifactory.corp.mongodb.com
          username: ${{ secrets.MDB_ARTIFACTORY_USERNAME }}
          password: ${{ secrets.MDB_ARTIFACTORY_PASSWORD }}

      - name: Install devbox
        uses: jetify-com/devbox-install-action@v0.14.0

      # Link updates to pr: all-in-one.yml, helm-updates, sdlc requirements
      - name: Generate deployment configurations
        working-directory: released-branch
        env:
          ENV: prod
          VERSION: ${{ env.VERSION }}
          IMAGE_URL: ${{ needs.compute-repo.outputs.repo }}
          OPERATOR_REGISTRY: ${{ needs.compute-repo.outputs.repo }}
        run: devbox run -- make bundle

      - name: Bump Helm chart version
        working-directory: released-branch
        run: devbox run -- scripts/bump-helm-chart-version.sh

      # Prepare SDLC requirement: signatures, sboms, compliance reports
      # Note: At this point, the image exists in prerelease registry with promoted tag, not yet tagged with version
      # We use the prerelease image with promoted tag for SBOM generation, then the image will be pushed with version tag later
      - name: Generate SBOMs
        working-directory: released-branch
        env:
          RELEASED_OPERATOR_IMAGE: ${{ env.DOCKER_PRERELEASE_REPO }}
          IMAGE_TAG: ${{ env.PROMOTED_TAG }}
          VERSION: ${{ env.VERSION }}
          SKIP_SIGNATURE_VERIFY: "true"
        run: devbox run -- make generate-sboms

      - name: Create SDLC report
        working-directory: released-branch
        run: devbox run -- make gen-sdlc-checklist

      - name: Generate licenses.csv
        working-directory: released-branch
        run: devbox run -- make build-licenses.csv

      # Create PR on release branch with all updates generated
      - name: Create release pr with all updated artefacts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          export BRANCH="new-release/${RELEASE_TAG}"
          export COMMIT_MESSAGE="feat: release ${RELEASE_TAG}"
          export RELEASE_DIR="releases/${RELEASE_TAG}"

          git config --global user.name "release-bot[bot]"
          git config --global user.email "456789+release-bot[bot]@users.noreply.github.com"
          
          # Create release directory (copy from released-branch)
          mkdir -p "$RELEASE_DIR"
          cp -rf released-branch/deploy "$RELEASE_DIR/"
          cp -rf released-branch/bundle "$RELEASE_DIR/"
          cp -rf released-branch/helm-charts "$RELEASE_DIR/"
          cp released-branch/bundle.Dockerfile "$RELEASE_DIR/bundle.Dockerfile"
          cp released-branch/licenses.csv "$RELEASE_DIR/"
          cp released-branch/docs/api-docs.md "$RELEASE_DIR/"

          git fetch origin
          git checkout -f -b "$BRANCH" origin/main
          git push -f origin "$BRANCH"

          # bump version.json (in released-branch, but output to current dir)
          (cd released-branch && devbox run -- make bump-version-file)
          cp released-branch/version.json .

          # Update Helm Charts on main
          cp -r "$RELEASE_DIR/helm-charts" .

          git add -f "$RELEASE_DIR" helm-charts version.json
          scripts/create-signed-commit.sh

          # Check if there is already openend PR
          existing_pr=$(gh pr list \
            --head "$BRANCH" \
            --base main \
            --state open \
            --json number \
            --jq '.[0].number')

          # If there is one, skip PR creating, since the branch is updated anyway
          if [ -z "$existing_pr" ]; then
            gh pr create \
              --draft \
              --base main \
              --head "$BRANCH" \
              --title "$COMMIT_MESSAGE" \
              --body "This is an autogenerated PR to prepare for the release."
          else
            echo "PR #$existing_pr already exists, skipping creation (branch updated)"
          fi

      # Create release artefacts on GitHub by tagging and pushing a tag
      - name: Create configuration package
        run: |
          set -x
          tar czvf atlas-operator-all-in-one-${{ env.VERSION }}.tar.gz -C releases/${{ env.RELEASE_TAG }}/deploy all-in-one.yaml

      - name: Tag the release assets
        run: |
          git fetch --tags
          # Force update tag to ensure it points to the correct commit (idempotent)
          # This will create the tag if it doesn't exist, or update it if it does
          git tag -f ${{ env.RELEASE_TAG }} ${{ needs.image2commit.outputs.commit_sha }}
          # Force push tag (idempotent - will update if exists, create if not)
          git push -f origin ${{ env.RELEASE_TAG }}

      - name: Ensure release is draft (if exists)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if release exists and ensure it's a draft
          RELEASE_JSON=$(gh release view "${{ env.RELEASE_TAG }}" --json draft,id 2>/dev/null || echo "{}")
          if [ "$(echo "$RELEASE_JSON" | jq -r '.id // empty')" != "" ]; then
            IS_DRAFT=$(echo "$RELEASE_JSON" | jq -r '.draft // false')
            if [ "$IS_DRAFT" != "true" ]; then
              echo "Warning: Release ${{ env.RELEASE_TAG }} exists but is not a draft. Updating to draft..."
              gh release edit "${{ env.RELEASE_TAG }}" --draft
            else
              echo "Release ${{ env.RELEASE_TAG }} already exists as draft"
            fi
          else
            echo "Release ${{ env.RELEASE_TAG }} does not exist yet, will be created as draft"
          fi

      - name: Create release on GitHub
        uses: softprops/action-gh-release@v2
        with:
          draft: true
          prerelease: ${{ github.event.inputs.release_type == 'pre-release' }}
          tag_name: "${{ env.RELEASE_TAG }}"
          name: "${{ env.RELEASE_TAG }}"
          token: ${{ secrets.GITHUB_TOKEN }}
          body_path: released-branch/docs/release-notes/release-notes-template.md
          # Note: action-gh-release@v2 automatically updates existing releases with the same tag (idempotent)
          # The step above ensures the release remains a draft when updating
          files: |
            ./atlas-operator-all-in-one-${{ env.VERSION }}.tar.gz
            ./released-branch/docs/releases/v${{ env.VERSION }}/sdlc-compliance.md
            ./released-branch/docs/releases/v${{ env.VERSION }}/linux_amd64.sbom.json
            ./released-branch/docs/releases/v${{ env.VERSION }}/linux_arm64.sbom.json

      # Safety check: Run certification in dry-run mode against prerelease image before publishing
      # This ensures the image will pass certification before we push it to public registries
      # Note: Registry login is performed earlier in the workflow (docker.io login step)
      - name: Pre-validate certification (dry-run)
        working-directory: released-branch
        run: devbox run -- make certify-openshift-images
        env:
          REGISTRY: docker.io
          REPOSITORY: mongodb/mongodb-atlas-kubernetes-operator-prerelease
          VERSION: ${{ env.PROMOTED_TAG }}
          RHCC_PROJECT: ${{ secrets.RH_CERTIFICATION_OSPID }}
          RHCC_TOKEN: ${{ secrets.RH_CERTIFICATION_PYXIS_API_TOKEN }}
          SUBMIT: false
          # Note: This runs against the prerelease image before it's pushed to quay.io
          # Preflight can check images from any registry, not just quay.io

      # Push, sign, and verify release images (atomic per target) - POINT OF NO RETURN
      # This is the most critical step and must be last after all preparation is complete
      # This handles: Docker release, Quay release, Quay certified, and copying back to prerelease
      - name: Push, sign, and verify release images
        working-directory: released-branch
        run: devbox run -- make push-release-images
        env:
          PKCS11_URI: ${{ secrets.PKCS11_URI }}
          GRS_USERNAME: ${{ secrets.GRS_USERNAME }}
          GRS_PASSWORD: ${{ secrets.GRS_PASSWORD }}
          VERSION: ${{ needs.compute-repo.outputs.image_version }}
          CERTIFIED_TAG: ${{ env.CERTIFIED_TAG }}

      # Certify OpenShift images (must happen after push-release-images creates the certified image)
      # This is the actual certification submission (if official-release)
      # Note: Registry login is performed earlier in the workflow (quay.io login step)
      - name: Certify Openshift images
        working-directory: released-branch
        run: devbox run -- make certify-openshift-images
        env:
          REGISTRY: quay.io
          REPOSITORY: ${{ needs.compute-repo.outputs.repo }}
          VERSION: ${{ env.CERTIFIED_TAG }}
          RHCC_PROJECT: ${{ secrets.RH_CERTIFICATION_OSPID }}
          RHCC_TOKEN: ${{ secrets.RH_CERTIFICATION_PYXIS_API_TOKEN }}
          SUBMIT: ${{ github.event.inputs.release_type == 'official-release' }}
