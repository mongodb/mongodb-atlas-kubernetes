package e2e2_test

import (
	"context"
	"embed"
	"os"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/mongodb/mongodb-atlas-kubernetes/v2/api"
	akov2generated "github.com/mongodb/mongodb-atlas-kubernetes/v2/internal/nextapi/generated/v1"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/control"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/e2e/k8s"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/e2e/utils"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/e2e2/kube"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/e2e2/operator"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/e2e2/yml"
)

//go:embed group/*
var groupResources embed.FS

var _ = Describe("Autogenerated Group Resource", Ordered, Label("group"), func() {
	var ako operator.Operator
	var kubeClient client.Client
	var orgID string
	var testNamespace *corev1.Namespace
	var resourcePrefix string
	// var groupID string

	_ = BeforeAll(func(ctx context.Context) {
		Expect(os.Setenv("EXPERIMENTAL", "true")).To(Succeed())
		ako = runTestAKO(DefaultGlobalCredentials, control.MustEnvVar("OPERATOR_NAMESPACE"), false)
		ako.Start(GinkgoT())

		client, err := kube.NewTestClient(true)
		Expect(err).ToNot(HaveOccurred())
		kubeClient = client

		orgID = control.MustEnvVar("MCLI_ORG_ID")
	})

	_ = AfterAll(func() {
		if ako != nil {
			ako.Stop(GinkgoT())
		}
	})

	_ = BeforeEach(func(ctx context.Context) {
		resourcePrefix = utils.RandomName("group")
		testNamespace = &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{
			Name: resourcePrefix + "-ns",
		}}
		Expect(kubeClient.Create(ctx, testNamespace)).To(Succeed())
		Expect(ako.Running()).To(BeTrue(), "Operator must be running")
	})

	_ = AfterEach(func(ctx context.Context) {
		if kubeClient == nil {
			return
		}
		Expect(kubeClient.Delete(ctx, testNamespace)).To(Succeed())
		Eventually(func(g Gomega) {
			g.Expect(kubeClient.Get(ctx, client.ObjectKeyFromObject(testNamespace), testNamespace)).ShouldNot(Succeed())
		}).WithTimeout(time.Minute).WithPolling(time.Second).To(Succeed())
	})

	DescribeTable(
		"Reconcile Group resource",
		func(ctx context.Context, objects, updatedObjets []client.Object) {
			var group *akov2generated.Group
			updatedGroups := make([]*akov2generated.Group, len(updatedObjets))

			By("Set object name and namespace", func() {
				for _, obj := range objects {
					if g, ok := obj.(*akov2generated.Group); ok {
						group = g
						group.SetName(resourcePrefix)
						group.SetNamespace(testNamespace.Name)
						group.Spec.V20250312.Entry.OrgId = orgID
					}
				}

				for i, obj := range updatedObjets {
					if g, ok := obj.(*akov2generated.Group); ok {
						updatedGroups[i] = g
					}
				}

				Expect(group).ToNot(BeNil())
			})

			By("Create/Import group", func() {
				Expect(kubeClient.Create(ctx, group)).To(Succeed())

				Eventually(func(g Gomega) {
					condition, err := k8s.GetStatusCondition(ctx, kubeClient, group, string(api.ReadyType))
					g.Expect(err).To(BeNil())
					g.Expect(condition.Status).To(Equal(metav1.ConditionTrue))

					condition, err = k8s.GetStatusCondition(ctx, kubeClient, group, "State")
					g.Expect(err).To(BeNil())
					g.Expect(condition.Reason).To(Equal("Created"))

					// groupID = *group.Status.V20250312.Id
				}).WithTimeout(5 * time.Minute).WithPolling(5 * time.Second).Should(Succeed())
			})

			By("Update group one time", func() {
				updatedGroups[0].ObjectMeta = group.ObjectMeta
				Expect(kubeClient.Update(ctx, updatedGroups[0])).To(Succeed())

				Eventually(func(g Gomega) {
					condition, err := k8s.GetStatusCondition(ctx, kubeClient, group, string(api.ReadyType))
					g.Expect(err).To(BeNil())
					g.Expect(condition.Status).To(Equal(metav1.ConditionTrue))

					condition, err = k8s.GetStatusCondition(ctx, kubeClient, group, "State")
					g.Expect(err).To(BeNil())
					g.Expect(condition.Reason).To(Equal("Updated"))
				}).WithTimeout(5 * time.Minute).WithPolling(5 * time.Second).Should(Succeed())
			})

			By("Update group second time", func() {
				updatedGroups[1].ObjectMeta = group.ObjectMeta
				Expect(kubeClient.Update(ctx, updatedGroups[1])).To(Succeed())

				Eventually(func(g Gomega) {
					condition, err := k8s.GetStatusCondition(ctx, kubeClient, group, string(api.ReadyType))
					g.Expect(err).To(BeNil())
					g.Expect(condition.Status).To(Equal(metav1.ConditionTrue))

					condition, err = k8s.GetStatusCondition(ctx, kubeClient, group, "State")
					g.Expect(err).To(BeNil())
					g.Expect(condition.Reason).To(Equal("Updated"))
				}).WithTimeout(5 * time.Minute).WithPolling(5 * time.Second).Should(Succeed())
			})

			By("Delete group", func() {
				Expect(kubeClient.Get(ctx, client.ObjectKey{Namespace: testNamespace.Name, Name: resourcePrefix}, group)).To(Succeed())
				Expect(kubeClient.Delete(ctx, group)).To(Succeed())

				Eventually(func(g Gomega) {
					g.Expect(kubeClient.Get(ctx, client.ObjectKey{Namespace: testNamespace.Name, Name: resourcePrefix}, group)).ToNot(Succeed())
				}).WithTimeout(30 * time.Minute).WithPolling(10 * time.Second).Should(Succeed())
			})
		},
		Entry(
			"Should create a new group",
			yml.MustParseObjects(yml.MustOpen(groupResources, "group/group_create.yaml")),
			yml.MustParseObjects(yml.MustOpen(groupResources, "group/group_update.yaml")),
		),
	)
})
