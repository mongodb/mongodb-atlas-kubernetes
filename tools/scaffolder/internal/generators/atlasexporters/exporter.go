// Copyright 2025 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package atlasexporters

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/mongodb/mongodb-atlas-kubernetes/tools/scaffolder/internal/boilerplate"
	"github.com/mongodb/mongodb-atlas-kubernetes/tools/scaffolder/internal/config"
	"github.com/mongodb/mongodb-atlas-kubernetes/tools/scaffolder/internal/generators/indexers"
)

const (
	translatorImportPath = "github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/crapi"
	objectImportPath     = "sigs.k8s.io/controller-runtime/pkg/client"
)

// GenerateExporter generates an exporter file for a CRD.
func GenerateExporter(kind, resourceName, resourceImportPath, destination string, mapping config.MappingWithConfig, referenceFields []indexers.ReferenceField) error {
	if err := os.MkdirAll(destination, 0755); err != nil {
		return fmt.Errorf("failed to create exporter directory: %w", err)
	}

	sdkImportPath := mapping.OpenAPIConfig.Package

	file := jen.NewFile("exporter")
	file.PackageComment("Code generated by generate-exporter. DO NOT EDIT.")
	file.PackageComment("nolint:dupl")
	boilerplate.AddLicenseHeader(file)

	file.ImportAlias(resourceImportPath, "akov2generated")

	structName := resourceName + "Exporter"
	file.Type().Id(structName).Struct(
		jen.Id("identifiers").Index().String(),
		jen.Line(),
		jen.Id("client").Op("*").Qual(sdkImportPath, "APIClient"),
		jen.Id("translator").Qual(translatorImportPath, "Translator"),
	)

	block := getBlock(resourceName, resourceImportPath)
	if len(referenceFields) > 0 {
		block = listBlock(resourceName, resourceImportPath, sdkImportPath, referenceFields)
	}

	file.Func().Params(jen.Id("e").Op("*").Id(structName)).Id("Export").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("referencedObjects").Index().Qual(objectImportPath, "Object"),
	).Params(
		jen.Index().Qual(objectImportPath, "Object"),
		jen.Error(),
	).Block(block...)

	file.Line()
	file.Func().Id("New"+structName).Params(
		jen.Id("client").Op("*").Qual(sdkImportPath, "APIClient"),
		jen.Id("translator").Qual(translatorImportPath, "Translator"),
		jen.Id("identifiers").Index().String(),
	).Op("*").Id(structName).Block(
		jen.Return(jen.Op("&").Id(structName).Values(jen.Dict{
			jen.Id("client"):      jen.Id("client"),
			jen.Id("translator"):  jen.Id("translator"),
			jen.Id("identifiers"): jen.Id("identifiers"),
		})),
	)

	fileName := filepath.Join(destination, strings.ToLower(resourceName)+"_exporter.go")

	return file.Save(fileName)
}

func getBlock(resourceName, resourceImportPath string) []jen.Code {
	return []jen.Code{
		jen.Id("resource").Op(":=").Op("&").Qual(resourceImportPath, resourceName).Values(),
		jen.Line(),
		jen.List(jen.Id("atlasResource"), jen.Id("_"), jen.Id("err")).
			Op(":=").
			Id("e").
			Dot("client").
			Dot(resourceName+"sApi").
			Dot("Get"+resourceName).
			Call(jen.Id("ctx"), jen.Id("e").Dot("identifiers").Index(jen.Lit(0))).
			Dot("Execute").
			Call(),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(
				jen.Nil(),
				jen.Qual("fmt", "Errorf").Call(
					jen.Lit(fmt.Sprintf("failed to get %s from Atlas: %%w", resourceName)),
					jen.Id("err"),
				),
			),
		),
		jen.Line(),
		jen.List(jen.Id("resources"), jen.Id("err")).
			Op(":=").
			Id("e").
			Dot("translator").
			Dot("FromAPI").
			Call(jen.Id("resource"), jen.Id("atlasResource"), jen.Id("referencedObjects").Op("...")),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(
				jen.Nil(),
				jen.Qual("fmt", "Errorf").Call(
					jen.Lit(fmt.Sprintf("failed to translate %s: %%w", resourceName)),
					jen.Id("err"),
				),
			),
		),
		jen.Line(),
		jen.Id("resource").Dot("GetObjectKind").Call().Dot("SetGroupVersionKind").Call(
			jen.Qual(resourceImportPath, "GroupVersion").Dot("WithKind").Call(jen.Lit(resourceName)),
		),
		jen.Line(),
		jen.Return(jen.Id("resources"), jen.Nil()),
	}
}

func listBlock(resourceName, resourceImportPath, sdkImportPath string, referenceFields []indexers.ReferenceField) []jen.Code {
	return []jen.Code{
		jen.Var().Id("atlasResources").Index().Any(),
		jen.For(jen.Id("pageNum").Op(":=").Lit(1).Op(";").Op(";").Id("pageNum").Op("++")).Block(
			jen.List(jen.Id("resp"), jen.Id("_"), jen.Id("err")).Op(":=").
				Id("e").Dot("client").Dot(resourceName+"sApi").Dot("List"+resourceName+"s").
				Call(listCallParams(referenceFields)...).Dot("PageNum").Call(jen.Id("pageNum")).Dot("Execute").Call(),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(
					jen.Nil(),
					jen.Qual("fmt", "Errorf").Call(
						jen.Lit(fmt.Sprintf("failed to list %ss from Atlas: %%w", resourceName)),
						jen.Id("err"),
					),
				),
			),
			jen.If(jen.Id("resp").Op("==").Nil()).Block(
				jen.Return(jen.Nil(), jen.Qual("errors", "New").Call(jen.Lit("no response"))),
			),
			jen.Id("pageResults").Op(":=").Id("resp").Dot("GetResults").Call(),
			jen.For(jen.Id("i").Op(":=").Range().Id("pageResults")).Block(
				jen.Id("atlasResources").Op("=").Append(jen.Id("atlasResources"), jen.Id("pageResults").Index(jen.Id("i"))),
			),
			jen.If(
				jen.Len(jen.Id("pageResults")).Op("==").Lit(0).Op("||").
					Len(jen.Id("atlasResources")).Op(">=").Id("resp").Dot("GetTotalCount").Call(),
			).Block(jen.Break()),
		),
		jen.Line(),
		jen.Id("resources").Op(":=").Make(
			jen.Index().Qual(objectImportPath, "Object"),
			jen.Lit(0),
			jen.Len(jen.Id("atlasResources")),
		),
		jen.For(jen.Id("_").Op(",").Id("atlasResource").Op(":=").Range().Id("atlasResources")).
			Block(
				jen.Id("resource").Op(":=").Op("&").Qual(resourceImportPath, resourceName).Values(),
				jen.List(jen.Id("translatedResources"), jen.Id("err")).
					Op(":=").
					Id("e").
					Dot("translator").
					Dot("FromAPI").
					Call(jen.Id("resource"), jen.Id("atlasResource"), jen.Id("referencedObjects").Op("...")),
				jen.If(jen.Id("err").Op("!=").Nil()).Block(
					jen.Return(
						jen.Nil(),
						jen.Qual("fmt", "Errorf").Call(
							jen.Lit(fmt.Sprintf("failed to translate %s: %%w", resourceName)),
							jen.Id("err"),
						),
					),
				),
				jen.Line(),
				jen.Id("resource").Dot("GetObjectKind").Call().Dot("SetGroupVersionKind").Call(
					jen.Qual(resourceImportPath, "GroupVersion").Dot("WithKind").Call(jen.Lit(resourceName)),
				),
				jen.Line(),
				jen.Id("resources").Op("=").Append(jen.Id("resources"), jen.Id("translatedResources").Op("...")),
			),
		jen.Line(),
		jen.Return(jen.Id("resources"), jen.Nil()),
	}
}

func listCallParams(referenceFields []indexers.ReferenceField) []jen.Code {
	params := make([]jen.Code, 0, len(referenceFields))
	params = append(params, jen.Id("ctx"))
	paramsCounter := 0
	for i := 0; i < len(referenceFields); i++ {
		if referenceFields[i].ReferencedKind != "Secret" && referenceFields[i].ReferencedKind != "ConfigMap" {
			params = append(params, jen.Id("e").Dot("identifiers").Index(jen.Lit(paramsCounter)))
			paramsCounter++
		}
	}
	return params
}
