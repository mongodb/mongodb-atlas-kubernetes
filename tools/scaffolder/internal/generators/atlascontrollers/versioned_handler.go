// Copyright 2025 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package atlascontrollers

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/mongodb/mongodb-atlas-kubernetes/tools/scaffolder/internal/boilerplate"
	"github.com/mongodb/mongodb-atlas-kubernetes/tools/scaffolder/internal/config"
	"github.com/mongodb/mongodb-atlas-kubernetes/tools/scaffolder/internal/generators/indexers"
)

func generateVersionHandlerFile(dir, resourceName, typesPath, indexerImportPath, resultPath string, mapping config.MappingWithConfig, override bool) error {
	atlasResourceName := strings.ToLower(resourceName)
	versionSuffix := mapping.Version
	apiPkg := typesPath
	sdkImportPath := mapping.OpenAPIConfig.Package

	fileName := filepath.Join(dir, "handler_"+versionSuffix+".go")

	// Check if a versioned handler file exists
	if !override {
		if _, err := os.Stat(fileName); err == nil {
			fmt.Printf("Skipping versioned handler %s (already exists, use --override to overwrite)\n", fileName)
			return nil
		}
	}

	f := jen.NewFile(atlasResourceName)
	boilerplate.AddLicenseHeader(f)

	f.ImportAlias(pkgCtrlState, "ctrlstate")
	f.ImportAlias(apiPkg, "akov2generated")
	f.ImportAlias(sdkImportPath, versionSuffix+"sdk")

	f.Type().Id("Handler"+versionSuffix).Struct(
		jen.Id("kubeClient").Qual("sigs.k8s.io/controller-runtime/pkg/client", "Client"),
		jen.Id("atlasClient").Op("*").Qual(sdkImportPath, "APIClient"),
		jen.Id("translator").Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/crapi", "Translator"),
		jen.Id("deletionProtection").Bool(),
	)

	f.Func().Id("NewHandler"+versionSuffix).Params(
		jen.Id("kubeClient").Qual("sigs.k8s.io/controller-runtime/pkg/client", "Client"),
		jen.Id("atlasClient").Op("*").Qual(sdkImportPath, "APIClient"),
		jen.Id("translator").Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/crapi", "Translator"),
		jen.Id("deletionProtection").Bool(),
	).Op("*").Id("Handler" + versionSuffix).Block(
		jen.Return(jen.Op("&").Id("Handler" + versionSuffix).Values(jen.Dict{
			jen.Id("kubeClient"):         jen.Id("kubeClient"),
			jen.Id("atlasClient"):        jen.Id("atlasClient"),
			jen.Id("translator"):         jen.Id("translator"),
			jen.Id("deletionProtection"): jen.Id("deletionProtection"),
		})),
	)

	generateVersionStateHandlers(f, resourceName, apiPkg, versionSuffix)
	generateVersionInterfaceMethods(f, resourceName, apiPkg, versionSuffix)

	if err := f.Save(fileName); err != nil {
		return err
	}

	return generateVersionHandlerGeneratedFile(dir, resourceName, typesPath, indexerImportPath, resultPath, mapping)
}

func generateVersionHandlerGeneratedFile(dir, resourceName, typesPath, indexerImportPath, resultPath string, mapping config.MappingWithConfig) error {
	atlasResourceName := strings.ToLower(resourceName)
	versionSuffix := mapping.Version
	apiPkg := typesPath

	fileName := filepath.Join(dir, "dependencies_"+versionSuffix+".go")

	referenceFields, err := indexers.ParseReferenceFields(resultPath, resourceName)
	if err != nil {
		return fmt.Errorf("failed to parse reference fields: %w", err)
	}

	dependentInfos, err := indexers.ParseDependentReferences(resultPath, resourceName)
	if err != nil {
		return fmt.Errorf("failed to parse dependent references: %w", err)
	}

	f := jen.NewFile(atlasResourceName)
	boilerplate.AddLicenseHeader(f)

	f.Comment("Code generated by scaffolder. DO NOT EDIT.")
	f.Line()

	f.ImportAlias(apiPkg, "akov2generated")

	generateGetDependenciesMethod(f, resourceName, apiPkg, versionSuffix, referenceFields)
	generateGetDependentsMethod(f, resourceName, apiPkg, versionSuffix, indexerImportPath, dependentInfos)

	return f.Save(fileName)
}

func generateVersionStateHandlers(f *jen.File, resourceName, apiPkg, versionSuffix string) {
	handlers := []struct {
		name      string
		nextState string
		message   string
	}{
		{"HandleInitial", "StateUpdated", "Updated Atlas" + resourceName + "."},
		{"HandleImportRequested", "StateImported", "Import completed"},
		{"HandleImported", "StateUpdated", "Ready"},
		{"HandleCreating", "StateCreated", "Resource created"},
		{"HandleCreated", "StateUpdated", "Ready"},
		{"HandleUpdating", "StateUpdated", "Update completed"},
		{"HandleUpdated", "StateUpdated", "Ready"},
		{"HandleDeletionRequested", "StateDeleting", "Deletion started"},
		{"HandleDeleting", "StateDeleted", "Deleted"},
	}

	resourceVarName := strings.ToLower(resourceName)

	for _, handler := range handlers {
		f.Comment(fmt.Sprintf("%s handles the %s state for version %s", handler.name, strings.ToLower(strings.TrimPrefix(handler.name, "Handle")), versionSuffix))

		methodBody := []jen.Code{
			jen.List(jen.Id("_"), jen.Err()).Op(":=").Id("h").Dot("getDependencies").Call(
				jen.Id("ctx"),
				jen.Id(resourceVarName),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(
					jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/result", "Error").Call(
						jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/state", "State"+strings.TrimPrefix(handler.name, "Handle")),
						jen.Qual("fmt", "Errorf").Call(
							jen.Lit(fmt.Sprintf("failed to resolve %s dependencies: %%w", resourceName)),
							jen.Err(),
						),
					),
				),
			),
			jen.Line(),
			jen.Comment("TODO: Implement " + strings.ToLower(strings.TrimPrefix(handler.name, "Handle")) + " state logic"),
			jen.Comment("TODO: Use h.atlasProvider.SdkClientSet(ctx, h.globalSecretRef, h.log) to get Atlas SDK client"),
			jen.Comment("TODO: Replace _ with deps and use deps variable when calling h.translator.ToAPI() methods"),
			jen.Return(jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/result", "NextState").Call(
				jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/state", handler.nextState),
				jen.Lit(handler.message),
			)),
		}

		f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id(handler.name).Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id(resourceVarName).Op("*").Qual(apiPkg, resourceName),
		).Params(
			jen.Qual(pkgCtrlState, "Result"),
			jen.Error(),
		).Block(methodBody...)
	}

	f.Line()
}

func generateGetDependenciesMethod(f *jen.File, resourceName, apiPkg, versionSuffix string, referenceFields []indexers.ReferenceField) {
	resourceVarName := strings.ToLower(resourceName)

	blockStatements := []jen.Code{
		jen.Var().Id("deps").Index().Qual("sigs.k8s.io/controller-runtime/pkg/client", "Object"),
		jen.Line(),
	}

	if len(referenceFields) == 0 {
		blockStatements = append(blockStatements, jen.Return(jen.Id("deps"), jen.Nil()))
	} else {
		for _, ref := range referenceFields {
			if strings.Contains(ref.FieldPath, ".items.") {
				continue
			}

			fieldAccessPath := strings.Replace(indexers.BuildFieldAccessPath(ref.FieldPath), "resource", resourceVarName, 1)
			nilCheckCondition := indexers.BuildNilCheckConditions(fieldAccessPath, ref.RequiredSegments)

			refKind := ref.ReferencedKind
			refVarName := strings.ToLower(refKind)

			var refPkgQual *jen.Statement
			if refKind == "Secret" {
				refPkgQual = jen.Qual("k8s.io/api/core/v1", refKind)
			} else {
				refPkgQual = jen.Qual(apiPkg, refKind)
			}

			blockStatements = append(blockStatements,
				jen.Comment(fmt.Sprintf("Check if %s is present", ref.FieldName)),
				jen.If(nilCheckCondition).Block(
					jen.Id(refVarName).Op(":=").Op("&").Add(refPkgQual).Values(),
					jen.Err().Op(":=").Id("h").Dot("kubeClient").Dot("Get").Call(
						jen.Id("ctx"),
						jen.Qual("sigs.k8s.io/controller-runtime/pkg/client", "ObjectKey").Values(jen.Dict{
							jen.Id("Name"):      jen.Id(fieldAccessPath).Dot("Name"),
							jen.Id("Namespace"): jen.Id(resourceVarName).Dot("GetNamespace").Call(),
						}),
						jen.Id(refVarName),
					),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Id("deps"), jen.Qual("fmt", "Errorf").Call(
							jen.Lit(fmt.Sprintf("failed to get %s %%s/%%s: %%w", refKind)),
							jen.Id(resourceVarName).Dot("GetNamespace").Call(),
							jen.Id(fieldAccessPath).Dot("Name"),
							jen.Err(),
						)),
					),
					jen.Line(),
					jen.Id("deps").Op("=").Append(jen.Id("deps"), jen.Id(refVarName)),
				),
				jen.Line(),
			)
		}

		blockStatements = append(blockStatements, jen.Return(jen.Id("deps"), jen.Nil()))
	}

	f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id("getDependencies").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id(resourceVarName).Op("*").Qual(apiPkg, resourceName),
	).Params(
		jen.Index().Qual("sigs.k8s.io/controller-runtime/pkg/client", "Object"),
		jen.Error(),
	).Block(blockStatements...)

	f.Line()
}

func generateGetDependentsMethod(f *jen.File, resourceName, apiPkg, versionSuffix, indexerImportPath string, dependentInfos []indexers.DependentInfo) {
	resourceVarName := strings.ToLower(resourceName)

	blockStatements := []jen.Code{
		jen.Var().Id("dependents").Index().Qual("sigs.k8s.io/controller-runtime/pkg/reconcile", "Request"),
		jen.Line(),
	}

	if len(dependentInfos) == 0 {
		blockStatements = append(blockStatements, jen.Return(jen.Id("dependents")))
	} else {
		for _, depInfo := range dependentInfos {
			blockStatements = append(blockStatements,
				jen.Id("dependents").Op("=").Append(
					jen.Id("dependents"),
					jen.Qual(indexerImportPath, depInfo.MapFuncName).
						Call(jen.Id("h").Dot("kubeClient")).
						Call(jen.Id("ctx"), jen.Id(resourceVarName)).Op("..."),
				),
			)
		}
		blockStatements = append(blockStatements, jen.Line(), jen.Return(jen.Id("dependents")))
	}

	f.Comment("getDependents returns all resources that reference this resource.")
	f.Comment("It uses the generated indexer MapFunc functions to find dependent resources.")
	f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id("getDependents").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id(resourceVarName).Op("*").Qual(apiPkg, resourceName),
	).Params(
		jen.Index().Qual("sigs.k8s.io/controller-runtime/pkg/reconcile", "Request"),
	).Block(blockStatements...)
}

func generateVersionInterfaceMethods(f *jen.File, resourceName, apiPkg, versionSuffix string) {
	f.Comment("For returns the resource and predicates for the controller")
	f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id("For").Params().Params(
		jen.Qual("sigs.k8s.io/controller-runtime/pkg/client", "Object"),
		jen.Qual("sigs.k8s.io/controller-runtime/pkg/builder", "Predicates"),
	).Block(
		jen.Return(jen.Op("&").Qual(apiPkg, resourceName).Values(), jen.Qual("sigs.k8s.io/controller-runtime/pkg/builder", "WithPredicates").Call()),
	)

	f.Comment("SetupWithManager sets up the controller with the Manager")
	f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id("SetupWithManager").Params(
		jen.Id("mgr").Qual("sigs.k8s.io/controller-runtime", "Manager"),
		jen.Id("rec").Qual("sigs.k8s.io/controller-runtime/pkg/reconcile", "Reconciler"),
		jen.Id("defaultOptions").Qual("sigs.k8s.io/controller-runtime/pkg/controller", "Options"),
	).Error().Block(
		jen.Comment("This method is not used for version-specific handlers but required by StateHandler interface"),
		jen.Return(jen.Nil()),
	)
}
