// Copyright 2025 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
)

const (
	translatorImportPath = "github.com/mongodb/mongodb-atlas-kubernetes/v2/internal/crapi"
	pagingImportPath     = "github.com/mongodb/mongodb-atlas-kubernetes/v2/internal/translation/paging"
	objectImportPath     = "sigs.k8s.io/controller-runtime/pkg/client"
)

type exporterRequest struct {
	crdPath            string
	kind               string
	resourceName       string
	resourceImportPath string
	destination        string
	mapping            MappingWithConfig
}

func generateResourceExporter(req *exporterRequest) error {
	if err := os.MkdirAll(req.destination, 0755); err != nil {
		return fmt.Errorf("failed to create exporter directory: %w", err)
	}

	sdkImportPath := req.mapping.OpenAPIConfig.Package
	referenceFields, err := ParseReferenceFields(req.crdPath, req.resourceName)
	if err != nil {
		return err
	}

	file := jen.NewFile("exporter")
	file.PackageComment("Code generated by generate-exporter. DO NOT EDIT.")
	file.PackageComment("nolint:dupl")
	AddLicenseHeader(file)

	file.ImportAlias(req.resourceImportPath, "akov2generated")

	structName := req.resourceName + "Exporter"
	file.Type().Id(structName).Struct(
		jen.Id("identifiers").Index().String(),
		jen.Line(),
		jen.Id("client").Op("*").Qual(sdkImportPath, "APIClient"),
		jen.Id("translator").Qual(translatorImportPath, "Translator"),
	)

	block := getBlock(req.resourceName, req.resourceImportPath)
	if len(referenceFields) > 0 {
		block = listBlock(req.resourceName, req.resourceImportPath, sdkImportPath, referenceFields)
	}

	file.Func().Params(jen.Id("e").Op("*").Id(structName)).Id("Export").Params(
		jen.Id("ctx").Qual("context", "Context"),
	).Params(
		jen.Index().Qual(objectImportPath, "Object"),
		jen.Error(),
	).Block(block...)

	file.Line()
	file.Func().Id("New"+structName).Params(
		jen.Id("client").Op("*").Qual(sdkImportPath, "APIClient"),
		jen.Id("translator").Qual(translatorImportPath, "Translator"),
		jen.Id("identifiers").Index().String(),
	).Op("*").Id(structName).Block(
		jen.Return(jen.Op("&").Id(structName).Values(jen.Dict{
			jen.Id("client"):      jen.Id("client"),
			jen.Id("translator"):  jen.Id("translator"),
			jen.Id("identifiers"): jen.Id("identifiers"),
		})),
	)

	fileName := filepath.Join(req.destination, strings.ToLower(req.resourceName)+"_exporter.go")

	return file.Save(fileName)
}

func getBlock(resourceName, resourceImportPath string) []jen.Code {
	return []jen.Code{
		jen.Id("resource").Op(":=").Op("&").Qual(resourceImportPath, resourceName).Values(),
		jen.Line(),
		jen.Comment("@TODO: Replace template with the correct API Resource name and method"),
		jen.List(jen.Id("atlasResource"), jen.Id("_"), jen.Id("err")).
			Op(":=").
			Id("e").
			Dot("client").
			Dot(resourceName+"sApi").
			Dot("Get"+resourceName).
			Call(jen.Id("ctx"), jen.Id("e").Dot("identifiers").Index(jen.Lit(0))).
			Dot("Execute").
			Call(),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		),
		jen.Line(),
		jen.List(jen.Id("resources"), jen.Id("err")).
			Op(":=").
			Id("e").
			Dot("translator").
			Dot("FromAPI").
			Call(jen.Id("resource"), jen.Id("atlasResource")),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		),
		jen.Line(),
		jen.Return(jen.Id("resources"), jen.Nil()),
	}
}

func listBlock(resourceName, resourceImportPath, sdkImportPath string, referenceFields []ReferenceField) []jen.Code {
	return []jen.Code{
		jen.Comment("@TODO: Replace template with the correct API Resource name and method"),
		jen.List(jen.Id("atlasResources"), jen.Id("err")).
			Op(":=").
			Qual(pagingImportPath, "ListAll").
			Call(
				jen.Id("ctx"),
				jen.Func().
					Params(jen.Id("ctx").Qual("context", "Context"), jen.Id("pageNum").Int()).
					Params(
						jen.Qual(pagingImportPath, "Response").Types(jen.Qual(sdkImportPath, "RESOURCE_TYPE")),
						jen.Op("*").Qual("net/http", "Response"),
						jen.Error(),
					).
					Block(
						jen.Return(
							jen.Id("e").
								Dot("client").
								Dot(resourceName+"sApi").
								Dot("List"+resourceName+"s").
								Call(listCallParams(referenceFields)...).
								Dot("Execute").
								Call(),
						),
					),
			),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		),
		jen.Line(),
		jen.Id("resources").Op(":=").Make(
			jen.Index().Qual(objectImportPath, "Object"),
			jen.Lit(0),
			jen.Len(jen.Id("atlasResources")),
		),
		jen.For(jen.Id("_").Op(",").Id("atlasResource").Op(":=").Range().Id("atlasResources")).
			Block(
				jen.Id("resource").Op(":=").Op("&").Qual(resourceImportPath, resourceName).Values(),
				jen.List(jen.Id("translatedResources"), jen.Id("err")).
					Op(":=").
					Id("e").
					Dot("translator").
					Dot("FromAPI").
					Call(jen.Id("resource"), jen.Id("atlasResource")),
				jen.If(jen.Id("err").Op("!=").Nil()).Block(
					jen.Return(jen.Nil(), jen.Id("err")),
				),
				jen.Line(),
				jen.Id("resources").Op("=").Append(jen.Id("resources"), jen.Id("translatedResources").Op("...")),
			),
		jen.Line(),
		jen.Return(jen.Id("resources"), jen.Nil()),
	}
}

func listCallParams(referenceFields []ReferenceField) []jen.Code {
	params := make([]jen.Code, 0, len(referenceFields))
	params = append(params, jen.Id("ctx"))
	paramsCounter := 0
	for i := 0; i < len(referenceFields); i++ {
		if referenceFields[i].ReferencedKind != "Secret" && referenceFields[i].ReferencedKind != "ConfigMap" {
			params = append(params, jen.Id("e").Dot("identifiers").Index(jen.Lit(paramsCounter)))
			paramsCounter++
		}
	}
	return params
}
