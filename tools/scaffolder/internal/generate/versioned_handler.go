package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
)

func generateVersionHandlerFile(dir, resourceName, typesPath, resultPath string, mapping MappingWithConfig, override bool) error {
	atlasResourceName := strings.ToLower(resourceName)
	versionSuffix := mapping.Version
	apiPkg := typesPath
	sdkImportPath := mapping.OpenAPIConfig.Package

	fileName := filepath.Join(dir, "handler_"+versionSuffix+".go")

	// Check if a versioned handler file exists
	if !override {
		if _, err := os.Stat(fileName); err == nil {
			fmt.Printf("Skipping versioned handler %s (already exists, use --override to overwrite)\n", fileName)
			return nil
		}
	}

	f := jen.NewFile(atlasResourceName)
	AddLicenseHeader(f)

	f.ImportAlias(pkgCtrlState, "ctrlstate")
	f.ImportAlias(apiPkg, "akov2generated")
	f.ImportAlias(sdkImportPath, versionSuffix+"sdk")

	f.Type().Id("Handler"+versionSuffix).Struct(
		jen.Id("kubeClient").Qual("sigs.k8s.io/controller-runtime/pkg/client", "Client"),
		jen.Id("atlasClient").Op("*").Qual(sdkImportPath, "APIClient"),
		jen.Id("translator").Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/crapi", "Translator"),
		jen.Id("deletionProtection").Bool(),
	)

	f.Func().Id("NewHandler"+versionSuffix).Params(
		jen.Id("kubeClient").Qual("sigs.k8s.io/controller-runtime/pkg/client", "Client"),
		jen.Id("atlasClient").Op("*").Qual(sdkImportPath, "APIClient"),
		jen.Id("translator").Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/crapi", "Translator"),
		jen.Id("deletionProtection").Bool(),
	).Op("*").Id("Handler" + versionSuffix).Block(
		jen.Return(jen.Op("&").Id("Handler" + versionSuffix).Values(jen.Dict{
			jen.Id("kubeClient"):         jen.Id("kubeClient"),
			jen.Id("atlasClient"):        jen.Id("atlasClient"),
			jen.Id("translator"):         jen.Id("translator"),
			jen.Id("deletionProtection"): jen.Id("deletionProtection"),
		})),
	)

	generateVersionStateHandlers(f, resourceName, apiPkg, versionSuffix)

	// Generate For and SetupWithManager methods to satisfy StateHandler interface
	generateVersionInterfaceMethods(f, resourceName, apiPkg, versionSuffix)

	if err := f.Save(fileName); err != nil {
		return err
	}

	// Generate the separate file for getDependencies and getDependents methods
	return generateVersionHandlerGeneratedFile(dir, resourceName, typesPath, resultPath, mapping)
}

// generateVersionHandlerGeneratedFile generates the dependencies_<version>.go file
// containing getDependencies and getDependents methods. This file is always regenerated
// and should not be manually edited.
func generateVersionHandlerGeneratedFile(dir, resourceName, typesPath, resultPath string, mapping MappingWithConfig) error {
	atlasResourceName := strings.ToLower(resourceName)
	versionSuffix := mapping.Version
	apiPkg := typesPath

	fileName := filepath.Join(dir, "dependencies_"+versionSuffix+".go")

	referenceFields, err := ParseReferenceFields(resultPath, resourceName)
	if err != nil {
		return fmt.Errorf("failed to parse reference fields: %w", err)
	}

	// Parse dependent references (resources that reference this resource)
	dependentInfos, err := ParseDependentReferences(resultPath, resourceName)
	if err != nil {
		return fmt.Errorf("failed to parse dependent references: %w", err)
	}

	f := jen.NewFile(atlasResourceName)
	AddLicenseHeader(f)

	// Add code generation warning comment
	f.Comment("Code generated by scaffolder. DO NOT EDIT.")
	f.Line()

	f.ImportAlias(apiPkg, "akov2generated")

	// Generate getDependencies method
	generateGetDependenciesMethod(f, resourceName, apiPkg, versionSuffix, referenceFields)

	// Generate getDependents method
	generateGetDependentsMethod(f, resourceName, apiPkg, versionSuffix, dependentInfos)

	return f.Save(fileName)
}

func generateVersionStateHandlers(f *jen.File, resourceName, apiPkg, versionSuffix string) {
	handlers := []struct {
		name      string
		nextState string
		message   string
	}{
		{"HandleInitial", "StateUpdated", "Updated Atlas" + resourceName + "."},
		{"HandleImportRequested", "StateImported", "Import completed"},
		{"HandleImported", "StateUpdated", "Ready"},
		{"HandleCreating", "StateCreated", "Resource created"},
		{"HandleCreated", "StateUpdated", "Ready"},
		{"HandleUpdating", "StateUpdated", "Update completed"},
		{"HandleUpdated", "StateUpdated", "Ready"},
		{"HandleDeletionRequested", "StateDeleting", "Deletion started"},
		{"HandleDeleting", "StateDeleted", "Deleted"},
	}

	resourceVarName := strings.ToLower(resourceName)

	for _, handler := range handlers {
		f.Comment(fmt.Sprintf("%s handles the %s state for version %s", handler.name, strings.ToLower(strings.TrimPrefix(handler.name, "Handle")), versionSuffix))

		// Build the method body with getDependencies call
		methodBody := []jen.Code{
			jen.List(jen.Id("_"), jen.Err()).Op(":=").Id("h").Dot("getDependencies").Call(
				jen.Id("ctx"),
				jen.Id(resourceVarName),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(
					jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/result", "Error").Call(
						jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/state", "State"+strings.TrimPrefix(handler.name, "Handle")),
						jen.Qual("fmt", "Errorf").Call(
							jen.Lit(fmt.Sprintf("failed to resolve %s dependencies: %%w", resourceName)),
							jen.Err(),
						),
					),
				),
			),
			jen.Line(),
			jen.Comment("TODO: Implement " + strings.ToLower(strings.TrimPrefix(handler.name, "Handle")) + " state logic"),
			jen.Comment("TODO: Use h.atlasProvider.SdkClientSet(ctx, h.globalSecretRef, h.log) to get Atlas SDK client"),
			jen.Comment("TODO: Replace _ with deps and use deps variable when calling h.translator.ToAPI() methods"),
			jen.Return(jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/result", "NextState").Call(
				jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/pkg/state", handler.nextState),
				jen.Lit(handler.message),
			)),
		}

		f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id(handler.name).Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id(resourceVarName).Op("*").Qual(apiPkg, resourceName),
		).Params(
			jen.Qual(pkgCtrlState, "Result"),
			jen.Error(),
		).Block(methodBody...)
	}

	// Add newline after the last state handler
	f.Line()
}

// generateGetDependenciesMethod generates the getDependencies method for the version-specific handler
func generateGetDependenciesMethod(f *jen.File, resourceName, apiPkg, versionSuffix string, referenceFields []ReferenceField) {
	resourceVarName := strings.ToLower(resourceName)

	blockStatements := []jen.Code{
		jen.Var().Id("deps").Index().Qual("sigs.k8s.io/controller-runtime/pkg/client", "Object"),
		jen.Line(),
	}

	if len(referenceFields) == 0 {
		blockStatements = append(blockStatements, jen.Return(jen.Id("deps"), jen.Nil()))
	} else {
		for _, ref := range referenceFields {
			// No array-based refs
			if strings.Contains(ref.FieldPath, ".items.") {
				continue
			}

			fieldAccessPath := strings.Replace(buildFieldAccessPath(ref.FieldPath), "resource", resourceVarName, 1)

			// Build nil check conditions using RequiredSegments to handle optional pointer fields
			nilCheckCondition := buildNilCheckConditions(fieldAccessPath, ref.RequiredSegments)

			refKind := ref.ReferencedKind
			refVarName := strings.ToLower(refKind)

			// TODO: simplify?
			var refPkgQual *jen.Statement
			if refKind == "Secret" {
				refPkgQual = jen.Qual("k8s.io/api/core/v1", refKind)
			} else {
				refPkgQual = jen.Qual(apiPkg, refKind)
			}

			blockStatements = append(blockStatements,
				jen.Comment(fmt.Sprintf("Check if %s is present", ref.FieldName)),
				jen.If(nilCheckCondition).Block(
					jen.Id(refVarName).Op(":=").Op("&").Add(refPkgQual).Values(),
					jen.Err().Op(":=").Id("h").Dot("kubeClient").Dot("Get").Call(
						jen.Id("ctx"),
						jen.Qual("sigs.k8s.io/controller-runtime/pkg/client", "ObjectKey").Values(jen.Dict{
							jen.Id("Name"):      jen.Id(fieldAccessPath).Dot("Name"),
							jen.Id("Namespace"): jen.Id(resourceVarName).Dot("GetNamespace").Call(),
						}),
						jen.Id(refVarName),
					),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Id("deps"), jen.Qual("fmt", "Errorf").Call(
							jen.Lit(fmt.Sprintf("failed to get %s %%s/%%s: %%w", refKind)),
							jen.Id(resourceVarName).Dot("GetNamespace").Call(),
							jen.Id(fieldAccessPath).Dot("Name"),
							jen.Err(),
						)),
					),
					jen.Line(),
					jen.Id("deps").Op("=").Append(jen.Id("deps"), jen.Id(refVarName)),
				),
				jen.Line(),
			)
		}

		blockStatements = append(blockStatements, jen.Return(jen.Id("deps"), jen.Nil()))
	}

	f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id("getDependencies").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id(resourceVarName).Op("*").Qual(apiPkg, resourceName),
	).Params(
		jen.Index().Qual("sigs.k8s.io/controller-runtime/pkg/client", "Object"),
		jen.Error(),
	).Block(blockStatements...)

	// Add newline after getDependencies method
	f.Line()
}

// generateGetDependentsMethod generates the getDependents method that finds all resources
// referencing this resource using the generated indexer MapFunc functions.
// This is the reverse of getDependencies - instead of finding what this resource references,
// it finds what references this resource.
//
// Example generated code for Group:
//
//	func (h *Handlerv20250312) getDependents(ctx context.Context, group *akov2generated.Group) []reconcile.Request {
//	    var dependents []reconcile.Request
//	    dependents = append(dependents, indexers.NewFlexClusterByGroupMapFunc(h.kubeClient)(ctx, group)...)
//	    dependents = append(dependents, indexers.NewDatabaseUserByGroupMapFunc(h.kubeClient)(ctx, group)...)
//	    dependents = append(dependents, indexers.NewClusterByGroupMapFunc(h.kubeClient)(ctx, group)...)
//	    return dependents
//	}
func generateGetDependentsMethod(f *jen.File, resourceName, apiPkg, versionSuffix string, dependentInfos []DependentInfo) {
	resourceVarName := strings.ToLower(resourceName)

	blockStatements := []jen.Code{
		jen.Var().Id("dependents").Index().Qual("sigs.k8s.io/controller-runtime/pkg/reconcile", "Request"),
		jen.Line(),
	}

	if len(dependentInfos) == 0 {
		// No dependents - just return empty slice
		blockStatements = append(blockStatements, jen.Return(jen.Id("dependents")))
	} else {
		// Add indexer calls for each dependent resource
		for _, depInfo := range dependentInfos {
			// Generate: dependents = append(dependents, indexers.New<DependentKind>By<TargetKind>MapFunc(h.kubeClient)(ctx, <resource>)...)
			blockStatements = append(blockStatements,
				jen.Id("dependents").Op("=").Append(
					jen.Id("dependents"),
					jen.Qual("github.com/mongodb/mongodb-atlas-kubernetes/v2/internal/generated/indexers", depInfo.MapFuncName).
						Call(jen.Id("h").Dot("kubeClient")).
						Call(jen.Id("ctx"), jen.Id(resourceVarName)).Op("..."),
				),
			)
		}
		blockStatements = append(blockStatements, jen.Line(), jen.Return(jen.Id("dependents")))
	}

	f.Comment("getDependents returns all resources that reference this resource.")
	f.Comment("It uses the generated indexer MapFunc functions to find dependent resources.")
	f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id("getDependents").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id(resourceVarName).Op("*").Qual(apiPkg, resourceName),
	).Params(
		jen.Index().Qual("sigs.k8s.io/controller-runtime/pkg/reconcile", "Request"),
	).Block(blockStatements...)
}

// generateVersionInterfaceMethods generates For and SetupWithManager methods for version-specific handlers
func generateVersionInterfaceMethods(f *jen.File, resourceName, apiPkg, versionSuffix string) {
	// For method
	f.Comment("For returns the resource and predicates for the controller")
	f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id("For").Params().Params(
		jen.Qual("sigs.k8s.io/controller-runtime/pkg/client", "Object"),
		jen.Qual("sigs.k8s.io/controller-runtime/pkg/builder", "Predicates"),
	).Block(
		jen.Return(jen.Op("&").Qual(apiPkg, resourceName).Values(), jen.Qual("sigs.k8s.io/controller-runtime/pkg/builder", "WithPredicates").Call()),
	)

	// SetupWithManager method
	f.Comment("SetupWithManager sets up the controller with the Manager")
	f.Func().Params(jen.Id("h").Op("*").Id("Handler"+versionSuffix)).Id("SetupWithManager").Params(
		jen.Id("mgr").Qual("sigs.k8s.io/controller-runtime", "Manager"),
		jen.Id("rec").Qual("sigs.k8s.io/controller-runtime/pkg/reconcile", "Reconciler"),
		jen.Id("defaultOptions").Qual("sigs.k8s.io/controller-runtime/pkg/controller", "Options"),
	).Error().Block(
		jen.Comment("This method is not used for version-specific handlers but required by StateHandler interface"),
		jen.Return(jen.Nil()),
	)
}
