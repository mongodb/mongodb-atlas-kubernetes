// Copyright 2025 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package exporter

import (
	"fmt"
	"syscall"
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions"
)

func TestMultiFileOpen(t *testing.T) {
	tests := map[string]struct {
		fs           afero.Fs
		dir          string
		preCreateDir bool
		expectedErr  error
	}{
		"creates directory if it does not exist": {
			fs:  afero.NewMemMapFs(),
			dir: "testdata/output",
		},
		"creates nested intermediate directories": {
			fs:  afero.NewMemMapFs(),
			dir: "testdata/nested/deep/output",
		},
		"succeeds if directory already exists": {
			fs:           afero.NewMemMapFs(),
			dir:          "testdata/output",
			preCreateDir: true,
		},
		"fails to create directory": {
			fs:          afero.NewReadOnlyFs(afero.NewMemMapFs()),
			dir:         "nonexistent/dir",
			expectedErr: fmt.Errorf("failed to create directory %s: %w", "nonexistent/dir", syscall.EPERM),
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			if tt.preCreateDir {
				require.NoError(t, tt.fs.MkdirAll(tt.dir, 0o755))
			}

			exp := NewMultiFileExporter(tt.fs, tt.dir, false)

			err := exp.Open()
			assert.Equal(t, tt.expectedErr, err)
			if err == nil {
				info, statErr := tt.fs.Stat(tt.dir)
				require.NoError(t, statErr)
				require.True(t, info.IsDir())
			}
		})
	}
}

func TestMultiFileExport(t *testing.T) {
	newBaseFs := func() afero.Fs {
		fs := afero.NewMemMapFs()
		_ = fs.MkdirAll("testdata/output", 0o755)
		return fs
	}

	tests := map[string]struct {
		fs            afero.Fs
		crds          []*apiextensionsv1.CustomResourceDefinition
		expectedFiles map[string]string
		expectedErr   string
	}{
		"exports single CRD to its own file": {
			fs:   newBaseFs(),
			crds: []*apiextensionsv1.CustomResourceDefinition{sampleCRD()},
			expectedFiles: map[string]string{
				"testdata/output/groups.atlas.generated.mongodb.com.yaml": "# The file is generated by openapi2crd\n" + expectedCRDBody,
			},
		},
		"exports multiple CRDs to separate files": {
			fs: newBaseFs(),
			crds: func() []*apiextensionsv1.CustomResourceDefinition {
				crd2 := sampleCRD()
				crd2.Name = "clusters.atlas.generated.mongodb.com"
				return []*apiextensionsv1.CustomResourceDefinition{sampleCRD(), crd2}
			}(),
			expectedFiles: map[string]string{
				"testdata/output/groups.atlas.generated.mongodb.com.yaml":   "# The file is generated by openapi2crd\n" + expectedCRDBody,
				"testdata/output/clusters.atlas.generated.mongodb.com.yaml": "",
			},
		},
		"fails when file cannot be opened": {
			fs:          afero.NewReadOnlyFs(newBaseFs()),
			crds:        []*apiextensionsv1.CustomResourceDefinition{sampleCRD()},
			expectedErr: "failed to open file",
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			exp := NewMultiFileExporter(tt.fs, "testdata/output", true)

			var exportErr error
			for _, crd := range tt.crds {
				if exportErr = exp.Export(crd); exportErr != nil {
					break
				}
			}

			if tt.expectedErr != "" {
				require.Error(t, exportErr)
				assert.Contains(t, exportErr.Error(), tt.expectedErr)
				return
			}

			require.NoError(t, exportErr)
			for filename, wantContent := range tt.expectedFiles {
				data, err := afero.ReadFile(tt.fs, filename)
				require.NoError(t, err, "file %s should exist", filename)
				if wantContent != "" {
					assert.Equal(t, wantContent, string(data))
				} else {
					assert.NotEmpty(t, data)
				}
			}
		})
	}
}
