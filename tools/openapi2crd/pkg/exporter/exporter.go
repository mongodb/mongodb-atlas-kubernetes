/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package exporter

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/pkg/errors"
	"github.com/spf13/afero"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/yaml"
)

const (
	createOrUpdate = os.O_WRONLY | os.O_CREATE | os.O_TRUNC

	defaultDirectoryPermission os.FileMode = 0o755
	defaultFilePermission      os.FileMode = 0o644
)

type Exporter interface {
	Export(final *apiextensionsv1.CustomResourceDefinition) error
}

// Filesystem exports the yaml config to file.
type Filesystem struct {
	fs        afero.Fs
	filename  string
	overwrite bool
}

func New(fs afero.Fs, outputFilepath string, overwrite bool) (*Filesystem, error) {
	return &Filesystem{
		fs:        fs,
		filename:  outputFilepath,
		overwrite: overwrite,
	}, nil
}

// Export exports the yaml config to file.
func (f *Filesystem) Export(final *apiextensions.CustomResourceDefinition) error {
	exists, err := afero.Exists(f.fs, f.filename)
	if err != nil {
		return fmt.Errorf("failed to check if file exists: %w", err)
	}

	if exists && !f.overwrite {
		return fmt.Errorf("file %s already exists, use --force to overwrite", f.filename)
	}

	if err = f.fs.MkdirAll(filepath.Dir(f.filename), defaultDirectoryPermission); err != nil {
		return fmt.Errorf("failed to create directory for file %s: %w", f.filename, err)
	}

	writer, err := f.fs.OpenFile(f.filename, createOrUpdate, defaultFilePermission)
	if err != nil {
		return fmt.Errorf("failed to open file %s: %w", f.filename, err)
	}

	_, err = writer.WriteString("# The file is generated by atlas2crd\n")
	if err != nil {
		return fmt.Errorf("failed to write the header to file %s: %w", f.filename, err)
	}

	yamlBytes, err := marshalCrd(final)
	if err != nil {
		return errors.New("Failed to marshall CRD when writing output")
	}

	_, err = writer.WriteString("---\n")
	if err != nil {
		return fmt.Errorf("failed to write the separator to file %s: %w", f.filename, err)
	}
	_, err = writer.Write(yamlBytes)
	if err != nil {
		return fmt.Errorf("failed to write the content to file %s: %w", f.filename, err)
	}

	return writer.Close()
}

func marshalCrd(crd *apiextensions.CustomResourceDefinition) ([]byte, error) {
	obj, err := convert(crd)
	if err != nil {
		return nil, err
	}

	obj.Kind = "CustomResourceDefinition"
	obj.APIVersion = "apiextensions.k8s.io/v1"

	yamlBytes, err := yaml.Marshal(obj)
	if err != nil {
		return nil, err
	}

	return yamlBytes, nil
}

func convert(crd *apiextensions.CustomResourceDefinition) (*apiextensionsv1.CustomResourceDefinition, error) {
	sch := runtime.NewScheme()
	_ = scheme.AddToScheme(sch)
	_ = apiextensions.AddToScheme(sch)
	_ = apiextensionsv1.AddToScheme(sch)
	_ = apiextensionsv1.RegisterConversions(sch)

	out := &apiextensionsv1.CustomResourceDefinition{}
	err := sch.Convert(crd, out, nil)
	if err != nil {
		return nil, err
	}

	return out, err
}
